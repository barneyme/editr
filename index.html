<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>editr</title>
        <link rel="manifest" href="manifest.json" />
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22 font-weight=%22bold%22 font-family=%22sans-serif%22>e</text></svg>"
        />
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            body {
                font-family: "Inter", sans-serif;
                background-color: #1a202c;
                color: #e2e8f0;
                cursor: default;
                user-select: none;
                /* Remove padding and centering for full-screen effect */
            }

            /* Hide the default scrollbar for a cleaner look */
            body::-webkit-scrollbar {
                width: 0;
                background: transparent;
            }

            .custom-scrollbar::-webkit-scrollbar {
                width: 12px;
            }
            .custom-scrollbar::-webkit-scrollbar-track {
                background: #2d3748;
            }
            .custom-scrollbar::-webkit-scrollbar-thumb {
                background-color: #4a5568;
                border-radius: 6px;
                border: 3px solid #2d3748;
            }

            #editor {
                resize: none;
                outline: none;
                scrollbar-width: thin; /* Firefox */
                scrollbar-color: #4a5568 #2d3748; /* Firefox */

                /* Corrected styles for line highlighting */
                line-height: 1.5rem; /* Ensure consistent line height */
                /* Change made here: The highlight color is now #2d3748 */
                background-image: linear-gradient(
                    to bottom,
                    #2d3748 0%,
                    #2d3748 1.5rem,
                    transparent 1.5rem,
                    transparent 100%
                );
                background-repeat: no-repeat;
                background-size: 100% 1.5rem;
                background-attachment: local;
                background-position-y: var(--highlight-y, 0px);
                transition: background-position-y 0.05s ease-out;
            }

            .fade-in {
                animation: fadeIn 0.1s ease-in-out forwards;
            }
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: scale(0.95);
                }
                to {
                    opacity: 1;
                    transform: scale(1);
                }
            }
        </style>
    </head>
    <body class="bg-gray-800 text-gray-200">
        <div
            id="editor-container"
            class="relative w-screen h-screen flex flex-col bg-gray-800"
        >
            <div
                class="bg-gray-900 text-gray-400 text-xs px-3 py-1 flex items-center justify-between relative"
            >
                <div class="flex items-center space-x-2">
                    <span id="file-status">Untitled.txt</span>
                </div>

                <span
                    class="absolute left-1/2 -translate-x-1/2 text-gray-200 font-bold text-sm"
                    >editr</span
                >

                <div class="flex items-center space-x-2">
                    <button
                        id="menu-button"
                        class="ml-auto p-1 rounded-sm hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-gray-500"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-4 w-4"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path
                                d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"
                            />
                        </svg>
                    </button>
                </div>
            </div>

            <textarea
                id="editor"
                spellcheck="false"
                class="flex-1 w-full p-4 md:p-6 bg-gray-800 text-gray-200 text-sm md:text-base leading-relaxed custom-scrollbar"
            ></textarea>
        </div>

        <div
            id="context-menu"
            class="absolute z-50 hidden bg-gray-700 text-sm rounded-lg shadow-2xl overflow-hidden min-w-[200px] border border-gray-600 fade-in"
        >
            <ul id="menu-list" class="divide-y divide-gray-600"></ul>
        </div>

        <input type="file" id="file-input" class="hidden" />
        <input
            type="file"
            id="expander-rules-input"
            class="hidden"
            accept=".txt"
        />

        <div
            id="message-box"
            class="fixed hidden bottom-4 left-1/2 -translate-x-1/2 bg-gray-900 text-gray-200 px-4 py-2 rounded-lg shadow-lg"
        >
            Message
        </div>

        <script>
            // Global variables for the elements
            const editorContainer = document.getElementById("editor-container");
            const editor = document.getElementById("editor");
            const contextMenu = document.getElementById("context-menu");
            const menuList = document.getElementById("menu-list");
            const messageBox = document.getElementById("message-box");
            const fileStatus = document.getElementById("file-status");
            const fileInput = document.getElementById("file-input");
            const expanderRulesInput = document.getElementById(
                "expander-rules-input",
            );
            const menuButton = document.getElementById("menu-button");

            // State management with localStorage
            const STORAGE_KEY = "fluxbox-editor-buffers";
            const CALENDAR_BUFFER_ID = "calendar-buffer";
            const CALCULATOR_BUFFER_ID = "calculator-buffer";
            const EXPANDER_BUFFER_ID = "expander-buffer"; // New constant for the expander buffer

            let bufferIds = []; // Stores the ordered IDs of the buffers
            let currentBufferId = null;
            let calendarDate = new Date();

            // --- Expander Rules Format ---
            // This text editor supports a text expansion feature. You can create your own
            // custom shortcuts and import them from a .txt file. The file must be in valid
            // JSON format.
            //
            // Each entry is a "key: value" pair.
            // - The `key` is the shortcut (e.g., "sig").
            // - The `value` is the text to expand to (e.g., "Best regards,\n- Your Name").
            //
            // Example format for the .txt file:
            // {
            //   "sig": "Best regards,\n- Your Name",
            //   "addr": "123 Main St,\nAnytown, USA 12345",
            //   "greet": "Hello, hope you're having a great day!"
            // }
            //
            // Note: The built-in shortcuts like 'd' will still work even if not in the imported file.
            // -----------------------------
            let expanderRules = {
                d: () => {
                    const d = new Date();
                    const yyyy = d.getFullYear();
                    const mm = String(d.getMonth() + 1).padStart(2, "0");
                    const dd = String(d.getDate()).padStart(2, "0");
                    return `${yyyy}${mm}${dd}`;
                },
                sig: "Best regards,\n- Your Name",
            };

            // Context menu items with their actions
            const menuActions = [
                {
                    text: "New File",
                    action: () => newFile(),
                    shortcut: "Ctrl + N",
                },
                {
                    text: "Open File",
                    action: () => openFile(),
                    shortcut: "Ctrl + O",
                },
                {
                    text: "Save File",
                    action: () => saveFile(),
                    shortcut: "Ctrl + S",
                },
                {
                    text: "Close File",
                    action: () => closeFile(),
                    shortcut: "Ctrl + W",
                },
                { text: "---" }, // Separator
                {
                    text: "Calculator",
                    action: () => newCalculator(),
                    shortcut: "Ctrl + Shift + M",
                },
                {
                    text: "Calendar",
                    action: () => newCalendar(),
                    shortcut: "Ctrl + Shift + C",
                },
                { text: "---" }, // Separator
                {
                    text: "Expander Rules",
                    action: () => newExpanderBuffer(),
                    shortcut: "Ctrl + E",
                },
                {
                    text: "Import Expander",
                    action: () => importExpanderRules(),
                },
                {
                    text: "Export Expander",
                    action: () => exportExpanderRules(),
                },
                { text: "---" }, // Separator
                {
                    text: "Previous Buffer",
                    action: () => switchBuffer(-1),
                    shortcut: "Ctrl + ←",
                },
                {
                    text: "Next Buffer",
                    action: () => switchBuffer(1),
                    shortcut: "Ctrl + →",
                },
            ];

            // Function to create and show the context menu
            function showContextMenu(x, y) {
                menuList.innerHTML = "";

                menuActions.forEach((item) => {
                    // Check if the item should be hidden in the current buffer
                    const isExpanderAction =
                        item.text === "Import Expander" ||
                        item.text === "Export Expander";
                    if (
                        isExpanderAction &&
                        currentBufferId !== EXPANDER_BUFFER_ID
                    ) {
                        return; // Skip this item
                    }

                    if (item.text === "---") {
                        const separator = document.createElement("li");
                        separator.className =
                            "my-1 mx-2 border-t border-gray-600";
                        menuList.appendChild(separator);
                    } else {
                        const listItem = document.createElement("li");
                        listItem.className =
                            "flex justify-between items-center px-4 py-2 hover:bg-gray-600 cursor-pointer transition-colors";
                        // Disable switching buttons if there's only one buffer
                        if (
                            item.text.includes("Buffer") &&
                            bufferIds.length <= 1
                        ) {
                            listItem.classList.add(
                                "opacity-50",
                                "cursor-not-allowed",
                            );
                            listItem.onclick = (e) => {
                                e.stopPropagation();
                                hideContextMenu();
                            };
                        } else {
                            listItem.onclick = (e) => {
                                e.stopPropagation();
                                item.action();
                                hideContextMenu();
                            };
                        }
                        listItem.innerHTML = `
                        <span>${item.text}</span>
                        ${item.shortcut ? `<span class="text-xs text-gray-400 ml-4">${item.shortcut}</span>` : ""}
                    `;
                        menuList.appendChild(listItem);
                    }
                });

                // Position the menu, adjusting for screen edges
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                contextMenu.style.display = "block"; // Temporarily show to get dimensions
                const menuWidth = contextMenu.offsetWidth;
                const menuHeight = contextMenu.offsetHeight;

                let finalX = x;
                let finalY = y;

                if (x + menuWidth > viewportWidth) {
                    finalX = viewportWidth - menuWidth - 5;
                }
                if (y + menuHeight > viewportHeight) {
                    finalY = y - menuHeight - 5;
                }
                if (finalY < 0) finalY = 5;

                contextMenu.style.left = `${finalX}px`;
                contextMenu.style.top = `${finalY}px`;
            }

            // Function to hide the context menu
            function hideContextMenu() {
                contextMenu.style.display = "none";
            }

            // Function to show a temporary message
            function showMessage(text) {
                messageBox.textContent = text;
                messageBox.classList.remove("hidden");
                setTimeout(() => {
                    messageBox.classList.add("hidden");
                }, 2000);
            }

            // Saves all buffers to localStorage
            function saveBuffers() {
                try {
                    const buffers = bufferIds.map((id) =>
                        JSON.parse(localStorage.getItem(id)),
                    );
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(buffers));
                    // Also save the expander rules buffer explicitly
                    saveExpanderRulesBuffer();
                } catch (e) {
                    console.error("Could not save buffers to localStorage:", e);
                    showMessage("Error saving files. Check console.");
                }
            }

            // Loads all buffers from localStorage
            function loadBuffers() {
                const storedBuffers = localStorage.getItem(STORAGE_KEY);
                if (storedBuffers) {
                    try {
                        const buffers = JSON.parse(storedBuffers);
                        buffers.forEach((buffer) => {
                            localStorage.setItem(
                                buffer.id,
                                JSON.stringify(buffer),
                            );
                        });
                        bufferIds = buffers.map((b) => b.id);
                        if (bufferIds.length > 0) {
                            currentBufferId = bufferIds[0];
                        }
                        // Load expander rules from its buffer if it exists
                        loadExpanderRulesFromBuffer();
                    } catch (e) {
                        console.error(
                            "Could not parse buffers from localStorage:",
                            e,
                        );
                    }
                }
            }

            // Updates the UI to match the current buffer
            function updateUI() {
                if (currentBufferId === null) {
                    editor.value = "";
                    fileStatus.textContent = "No open files";
                    return;
                }

                const currentFile = JSON.parse(
                    localStorage.getItem(currentBufferId),
                );
                if (!currentFile) {
                    console.error("Current buffer not found in localStorage.");
                    newFile(); // Fallback to creating a new file
                    return;
                }

                editor.value = currentFile.content;
                const currentBufferIndex = bufferIds.indexOf(currentBufferId);
                fileStatus.textContent = `${currentFile.name} (${currentBufferIndex + 1}/${bufferIds.length})`;
                showMessage(`Switched to: ${currentFile.name}`);
            }

            // Main actions
            function newFile() {
                const newId = `buffer-${Date.now()}`;
                const newFileObject = {
                    id: newId,
                    name: `Untitled-${bufferIds.length + 1}.txt`,
                    content: "",
                };
                localStorage.setItem(newId, JSON.stringify(newFileObject));
                bufferIds.push(newId);
                currentBufferId = newId;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            function openFile() {
                // Programmatically click the hidden file input
                fileInput.click();
            }

            // Event listener for the file input change
            fileInput.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Check if the file is a supported plaintext type
                const fileName = file.name.toLowerCase();
                const supportedExtensions = [
                    ".txt",
                    ".md",
                    ".html",
                    ".js",
                    ".css",
                    ".json",
                    ".bat",
                    ".ps1",
                    ".sh",
                    ".csv",
                    ".tsv",
                    ".log",
                    ".xml",
                ];
                const isSupported = supportedExtensions.some((ext) =>
                    fileName.endsWith(ext),
                );

                const reader = new FileReader();
                reader.onload = (event) => {
                    const newId = `buffer-${Date.now()}`;
                    const newFileObject = {
                        id: newId,
                        name: file.name,
                        content: event.target.result,
                    };
                    localStorage.setItem(newId, JSON.stringify(newFileObject));
                    bufferIds.push(newId);
                    currentBufferId = newId;
                    saveBuffers();
                    updateUI();
                    editor.focus();
                    showMessage(`Opened file: ${file.name}`);
                };
                reader.readAsText(file);
            });

            function saveFile() {
                if (currentBufferId === null) {
                    showMessage("No file to save.");
                    return;
                }
                const currentFile = JSON.parse(
                    localStorage.getItem(currentBufferId),
                );
                const content = editor.value; // Use the live editor content
                const blob = new Blob([content], { type: "text/plain" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = currentFile.name;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage("File saved.");
            }

            function closeFile() {
                if (currentBufferId === null) {
                    showMessage("No file to close.");
                    return;
                }

                const index = bufferIds.indexOf(currentBufferId);
                localStorage.removeItem(currentBufferId);
                bufferIds.splice(index, 1);

                if (bufferIds.length === 0) {
                    currentBufferId = null;
                    editor.value = "";
                    newFile();
                } else {
                    const nextIndex = Math.max(0, index - 1);
                    currentBufferId = bufferIds[nextIndex];
                    updateUI();
                }
                saveBuffers();
            }

            function switchBuffer(direction) {
                if (bufferIds.length <= 1) {
                    showMessage("No other files to switch to.");
                    return;
                }
                const currentIndex = bufferIds.indexOf(currentBufferId);
                const nextIndex =
                    (currentIndex + direction + bufferIds.length) %
                    bufferIds.length;
                currentBufferId = bufferIds[nextIndex];
                updateUI();
            }

            function selectAll() {
                editor.select();
                showMessage("All text selected.");
            }

            // --- Custom Buffer Logic: Calculator and Calendar ---

            function newCalculator() {
                if (bufferIds.includes(CALCULATOR_BUFFER_ID)) {
                    currentBufferId = CALCULATOR_BUFFER_ID;
                    updateUI();
                    return;
                }
                const newFileObject = {
                    id: CALCULATOR_BUFFER_ID,
                    name: "Calculator",
                    content:
                        "--- Simple Calculator ---\nType a mathematical expression and press Enter.\n\n",
                };
                localStorage.setItem(
                    CALCULATOR_BUFFER_ID,
                    JSON.stringify(newFileObject),
                );
                bufferIds.push(CALCULATOR_BUFFER_ID);
                currentBufferId = CALCULATOR_BUFFER_ID;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            function generateCalendarString(date) {
                const monthNames = [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                ];
                const dayNames = ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"];

                const year = date.getFullYear();
                const month = date.getMonth();
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0).getDate();
                const startDay = (firstDay.getDay() + 6) % 7;

                let output = `[<] Previous Month     [>] Next Month\n\n`;
                output += `        ${monthNames[month]} ${year}\n`;
                output += `  ${dayNames.join("  ")}\n`;
                output += `--------------------------\n`;

                let day = 1;
                let currentLine = "";
                for (let i = 0; i < 7; i++) {
                    if (i < startDay) {
                        currentLine += "    ";
                    } else {
                        const dayString = day.toString().padStart(2, " ");
                        currentLine += `${dayString}  `;
                        day++;
                    }
                }
                output += currentLine.trim() + "\n";

                while (day <= lastDay) {
                    currentLine = "";
                    for (let i = 0; i < 7 && day <= lastDay; i++) {
                        const dayString = day.toString().padStart(2, " ");
                        currentLine += `${dayString}  `;
                        day++;
                    }
                    output += currentLine.trim() + "\n";
                }

                return output;
            }

            function newCalendar() {
                if (bufferIds.includes(CALENDAR_BUFFER_ID)) {
                    currentBufferId = CALENDAR_BUFFER_ID;
                    updateUI();
                    return;
                }
                const newFileObject = {
                    id: CALENDAR_BUFFER_ID,
                    name: "Calendar",
                    content: generateCalendarString(calendarDate),
                };
                localStorage.setItem(
                    CALENDAR_BUFFER_ID,
                    JSON.stringify(newFileObject),
                );
                bufferIds.push(CALENDAR_BUFFER_ID);
                currentBufferId = CALENDAR_BUFFER_ID;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            // --- New Expander Rules Buffer Logic ---

            function newExpanderBuffer() {
                if (bufferIds.includes(EXPANDER_BUFFER_ID)) {
                    currentBufferId = EXPANDER_BUFFER_ID;
                    updateUI();
                    return;
                }

                // Generate content from the current rules
                const initialContent = JSON.stringify(expanderRules, null, 2);

                const newFileObject = {
                    id: EXPANDER_BUFFER_ID,
                    name: "Expander Rules",
                    content: `
// Edit your text expansion rules here in JSON format.
// Save this buffer to apply changes.
// Example:
// {
//   "e": "you@email.com",
//   "p": "(555) 555-5555"
// }
// Note: Add , to end of each expander line except last.
// Note: 'd' reserved for YYYYMMDD.
// -------------------------------------------------------------
${initialContent}
`.trim(),
                };
                localStorage.setItem(
                    EXPANDER_BUFFER_ID,
                    JSON.stringify(newFileObject),
                );
                bufferIds.push(EXPANDER_BUFFER_ID);
                currentBufferId = EXPANDER_BUFFER_ID;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            function saveExpanderRulesBuffer() {
                const expanderBuffer = JSON.parse(
                    localStorage.getItem(EXPANDER_BUFFER_ID),
                );
                if (expanderBuffer) {
                    try {
                        const newRules = JSON.parse(
                            expanderBuffer.content.replace(/\/\/.*/g, ""),
                        ); // Remove comments
                        // Merge the new rules, but keep the function-based ones
                        for (const key in newRules) {
                            if (typeof expanderRules[key] === "function") {
                                // Keep the function-based rule as-is
                            } else {
                                expanderRules[key] = newRules[key];
                            }
                        }
                        showMessage("Expander rules updated from buffer.");
                    } catch (e) {
                        showMessage(
                            "Error: The Expander Rules buffer is not valid JSON.",
                        );
                    }
                }
            }

            function loadExpanderRulesFromBuffer() {
                const expanderBuffer = JSON.parse(
                    localStorage.getItem(EXPANDER_BUFFER_ID),
                );
                if (expanderBuffer) {
                    try {
                        const newRules = JSON.parse(
                            expanderBuffer.content.replace(/\/\/.*/g, ""),
                        );
                        expanderRules = { ...expanderRules, ...newRules };
                    } catch (e) {
                        // The buffer might be empty or invalid on first load, so we just ignore the error.
                    }
                }
            }

            // Expander rules import/export logic
            function importExpanderRules() {
                expanderRulesInput.click();
            }

            function exportExpanderRules() {
                const rulesToExport = {};
                // Filter out any function-based rules for export, e.g., 'd'
                for (const key in expanderRules) {
                    if (typeof expanderRules[key] !== "function") {
                        rulesToExport[key] = expanderRules[key];
                    }
                }
                const content = JSON.stringify(rulesToExport, null, 2);
                const blob = new Blob([content], { type: "text/plain" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "expander_rules.txt";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage("Expander rules saved to expander_rules.txt.");
            }

            // Event listener for importing expander rules
            expanderRulesInput.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedRules = JSON.parse(event.target.result);
                        // Merge imported rules with existing ones, overwriting duplicates
                        expanderRules = { ...expanderRules, ...importedRules };
                        showMessage(
                            "Expander rules imported successfully from .txt file.",
                        );
                    } catch (error) {
                        showMessage(
                            "Error: Could not import rules. The .txt file is not in valid JSON format.",
                        );
                    }
                };
                reader.readAsText(file);
            });

            // Event listener for the text expander functionality
            editor.addEventListener("input", () => {
                const cursorPosition = editor.selectionStart;
                const text = editor.value;

                // Check if there are at least two characters to check for the trigger
                if (cursorPosition >= 2) {
                    const triggerPrefix = text.substring(
                        cursorPosition - 2,
                        cursorPosition,
                    );
                    if (
                        triggerPrefix.startsWith(".") &&
                        expanderRules[triggerPrefix.substring(1)]
                    ) {
                        const rule = expanderRules[triggerPrefix.substring(1)];
                        const expansion =
                            typeof rule === "function" ? rule() : rule;

                        // Replace the trigger with the expanded text
                        const newText =
                            text.substring(0, cursorPosition - 2) +
                            expansion +
                            text.substring(cursorPosition);
                        editor.value = newText;

                        // Move the cursor to the end of the newly inserted text
                        const newCursorPosition =
                            cursorPosition - 2 + expansion.length;
                        editor.selectionStart = newCursorPosition;
                        editor.selectionEnd = newCursorPosition;

                        // Update the buffer
                        if (currentBufferId !== null) {
                            const currentFile = JSON.parse(
                                localStorage.getItem(currentBufferId),
                            );
                            currentFile.content = newText;
                            localStorage.setItem(
                                currentBufferId,
                                JSON.stringify(currentFile),
                            );
                        }
                    }
                }
            });

            // Function to update the line highlight
            const updateLineHighlight = () => {
                // Get the current cursor position
                const cursorPosition = editor.selectionStart;
                // Get the text before the cursor
                const textBeforeCursor = editor.value.substring(
                    0,
                    cursorPosition,
                );
                // Count the number of newline characters to get the line number (0-indexed)
                const lineNumber = (textBeforeCursor.match(/\n/g) || []).length;

                // Get the computed line height and padding
                const computedStyle = window.getComputedStyle(editor);
                const lineHeight = parseFloat(computedStyle.lineHeight);
                const paddingTop = parseFloat(computedStyle.paddingTop);

                // Calculate the vertical position for the highlight
                const highlightY = lineNumber * lineHeight + paddingTop;

                // Set the CSS custom property on the editor element
                editor.style.setProperty("--highlight-y", `${highlightY}px`);
            };

            // Event listeners
            // Right-click to show the menu
            document.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                // Show menu to the right of the cursor
                showContextMenu(e.clientX, e.clientY);
            });

            // Click the menu button to show the menu
            menuButton.addEventListener("click", (e) => {
                e.stopPropagation();
                const rect = menuButton.getBoundingClientRect();
                // Position the menu to the left, aligned with the button
                const menuWidth = contextMenu.offsetWidth;
                const x = rect.right - menuWidth;
                const y = rect.bottom;
                showContextMenu(x, y);
            });

            document.addEventListener("click", (e) => {
                // Hide the menu if the user clicks anywhere but the menu itself or the button
                if (
                    !contextMenu.contains(e.target) &&
                    e.target !== menuButton &&
                    !menuButton.contains(e.target)
                ) {
                    hideContextMenu();
                }
            });

            // Drag and drop functionality
            editorContainer.addEventListener("dragover", (e) => {
                e.preventDefault();
                editorContainer.classList.add(
                    "border-4",
                    "border-blue-500",
                    "border-dashed",
                );
            });

            editorContainer.addEventListener("dragleave", (e) => {
                editorContainer.classList.remove(
                    "border-4",
                    "border-blue-500",
                    "border-dashed",
                );
            });

            editorContainer.addEventListener("drop", (e) => {
                e.preventDefault();
                editorContainer.classList.remove(
                    "border-4",
                    "border-blue-500",
                    "border-dashed",
                );

                const file = e.dataTransfer.files[0];
                if (!file) {
                    showMessage("No file was dropped.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    const newId = `buffer-${Date.now()}`;
                    const newFileObject = {
                        id: newId,
                        name: file.name,
                        content: event.target.result,
                    };
                    localStorage.setItem(newId, JSON.stringify(newFileObject));
                    bufferIds.push(newId);
                    currentBufferId = newId;
                    saveBuffers();
                    updateUI();
                    editor.focus();
                    showMessage(`Opened file: ${file.name}`);
                };
                reader.readAsText(file);
            });

            // Sync editor content with the current buffer in real-time
            editor.addEventListener("input", () => {
                if (currentBufferId !== null) {
                    const currentFile = JSON.parse(
                        localStorage.getItem(currentBufferId),
                    );
                    currentFile.content = editor.value;
                    localStorage.setItem(
                        currentBufferId,
                        JSON.stringify(currentFile),
                    );
                }
            });

            // Auto-pairing of brackets, quotes, etc.
            editor.addEventListener("input", (e) => {
                const pairings = {
                    "(": ")",
                    "[": "]",
                    "{": "}",
                    '"': '"',
                    "'": "'",
                    "`": "`",
                };
                const cursorPosition = editor.selectionStart;
                const text = editor.value;
                const char = text.charAt(cursorPosition - 1);

                if (pairings[char]) {
                    const newText =
                        text.substring(0, cursorPosition) +
                        pairings[char] +
                        text.substring(cursorPosition);
                    editor.value = newText;
                    editor.selectionStart = cursorPosition;
                    editor.selectionEnd = cursorPosition;
                }
            });

            // Listen for changes to update the highlight position
            editor.addEventListener("input", updateLineHighlight);
            editor.addEventListener("click", updateLineHighlight);
            editor.addEventListener("scroll", updateLineHighlight);

            // Keyboard shortcuts and special key behaviors
            editor.addEventListener("keydown", (e) => {
                // Fix: Call updateLineHighlight on arrow key presses
                if (
                    e.key === "ArrowUp" ||
                    e.key === "ArrowDown" ||
                    e.key === "ArrowLeft" ||
                    e.key === "ArrowRight"
                ) {
                    // Use setTimeout to ensure the cursor position has updated before calculating highlight
                    setTimeout(updateLineHighlight, 0);
                }

                const cursorPosition = editor.selectionStart;
                const text = editor.value;
                const lineStart =
                    text.lastIndexOf("\n", cursorPosition - 1) + 1;
                const line = text.substring(lineStart, cursorPosition);

                // If it's the expander buffer, save the changes on Enter
                if (currentBufferId === EXPANDER_BUFFER_ID) {
                    if (e.key === "Enter") {
                        saveExpanderRulesBuffer();
                    }
                }

                // Special functionality for Calculator and Calendar buffers
                if (
                    e.key === "Enter" &&
                    currentBufferId === CALCULATOR_BUFFER_ID
                ) {
                    e.preventDefault();
                    try {
                        // Safely evaluate the expression
                        const result = Function(
                            `'use strict'; return (${line})`,
                        )();
                        editor.value += `\n= ${result}\n`;
                    } catch (err) {
                        editor.value += `\n= Error: Invalid expression\n`;
                    }
                    editor.scrollTop = editor.scrollHeight;
                }

                // New logic for calendar navigation with arrow keys
                if (currentBufferId === CALENDAR_BUFFER_ID) {
                    if (e.key === "ArrowLeft") {
                        e.preventDefault();
                        calendarDate.setMonth(calendarDate.getMonth() - 1);
                        const newContent = generateCalendarString(calendarDate);
                        const currentFile = JSON.parse(
                            localStorage.getItem(CALENDAR_BUFFER_ID),
                        );
                        currentFile.content = newContent;
                        localStorage.setItem(
                            CALENDAR_BUFFER_ID,
                            JSON.stringify(currentFile),
                        );
                        editor.value = newContent;
                        showMessage("Previous Month");
                    } else if (e.key === "ArrowRight") {
                        e.preventDefault();
                        calendarDate.setMonth(calendarDate.getMonth() + 1);
                        const newContent = generateCalendarString(calendarDate);
                        const currentFile = JSON.parse(
                            localStorage.getItem(CALENDAR_BUFFER_ID),
                        );
                        currentFile.content = newContent;
                        localStorage.setItem(
                            CALENDAR_BUFFER_ID,
                            JSON.stringify(currentFile),
                        );
                        editor.value = newContent;
                        showMessage("Next Month");
                    }
                }

                // Tab indentation
                if (e.key === "Tab") {
                    e.preventDefault();
                    const start = editor.selectionStart;
                    const end = editor.selectionEnd;
                    editor.value =
                        text.substring(0, start) + "    " + text.substring(end);
                    editor.selectionStart = editor.selectionEnd = start + 4;
                }

                // Auto-indented lists
                if (
                    e.key === "Enter" &&
                    currentBufferId !== EXPANDER_BUFFER_ID
                ) {
                    const listMatch = line.match(/^(\s*)([*-]|\d+\.)\s/);

                    if (listMatch) {
                        e.preventDefault();
                        const [indentation, marker] = [
                            listMatch[1],
                            listMatch[2],
                        ];

                        if (line.trim() === marker.trim()) {
                            // If empty list item, exit the list
                            const newText =
                                text.substring(0, lineStart) +
                                text.substring(cursorPosition);
                            editor.value = newText;
                            editor.selectionStart = editor.selectionEnd =
                                lineStart;
                        } else {
                            // Continue the list
                            let newMarker = marker;
                            if (marker.match(/\d+\./)) {
                                const number =
                                    parseInt(marker.replace(".", "")) + 1;
                                newMarker = `${number}.`;
                            }

                            const newText =
                                text.substring(0, cursorPosition) +
                                "\n" +
                                indentation +
                                newMarker +
                                " " +
                                text.substring(cursorPosition);
                            editor.value = newText;
                            editor.selectionStart = editor.selectionEnd =
                                cursorPosition +
                                1 +
                                indentation.length +
                                newMarker.length +
                                1;
                        }
                    }
                }

                // Other keyboard shortcuts
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case "n":
                            e.preventDefault();
                            newFile();
                            break;
                        case "o":
                            e.preventDefault();
                            openFile();
                            break;
                        case "s":
                            e.preventDefault();
                            saveFile();
                            break;
                        case "w":
                            e.preventDefault();
                            closeFile();
                            break;
                        case "m":
                            if (e.shiftKey) {
                                e.preventDefault();
                                newCalculator();
                            }
                            break;
                        case "c":
                            if (e.shiftKey) {
                                e.preventDefault();
                                newCalendar();
                            }
                            break;
                        case "e":
                            e.preventDefault();
                            newExpanderBuffer();
                            break;
                        case "ArrowLeft":
                            e.preventDefault();
                            switchBuffer(-1);
                            break;
                        case "ArrowRight":
                            e.preventDefault();
                            switchBuffer(1);
                            break;
                    }
                }
            });

            // Initialize the editor with one new, empty file on page load
            window.onload = () => {
                loadBuffers();
                if (bufferIds.length === 0) {
                    newFile();
                } else {
                    updateUI();
                }
                editor.focus();
                // Set the initial highlight position
                updateLineHighlight();
            };
        </script>
    </body>
</html>
