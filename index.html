<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>editr</title>
        <link rel="manifest" href="./manifest.json" />
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22 font-weight=%22bold%22 font-family=%22sans-serif%22>e</text></svg>"
        />
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            body {
                font-family: "Inter", sans-serif;
                background-color: #1a202c;
                color: #e2e8f0;
                cursor: default;
                user-select: none;
            }

            body::-webkit-scrollbar {
                width: 0;
                background: transparent;
            }

            .custom-scrollbar::-webkit-scrollbar {
                width: 12px;
            }
            .custom-scrollbar::-webkit-scrollbar-track {
                background: #2d3748;
            }
            .custom-scrollbar::-webkit-scrollbar-thumb {
                background-color: #4a5568;
                border-radius: 6px;
                border: 3px solid #2d3748;
            }

            #editor {
                resize: none;
                outline: none;
                scrollbar-width: thin;
                scrollbar-color: #4a5568 #2d3748;

                line-height: 1.5rem;
                background-image: linear-gradient(
                    to bottom,
                    #2d3748 0%,
                    #2d3748 1.5rem,
                    transparent 1.5rem,
                    transparent 100%
                );
                background-repeat: no-repeat;
                background-size: 100% 1.5rem;
                background-attachment: local;
                background-position-y: var(--highlight-y, 0px);
                transition: background-position-y 0.05s ease-out;
            }

            .fade-in {
                animation: fadeIn 0.1s ease-in-out forwards;
            }
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: scale(0.95);
                }
                to {
                    opacity: 1;
                    transform: scale(1);
                }
            }
        </style>
    </head>
    <body class="bg-gray-800 text-gray-200">
        <div
            id="editor-container"
            class="relative w-screen h-screen flex flex-col bg-gray-800"
        >
            <div
                class="bg-gray-900 text-gray-400 text-xs px-3 py-1 flex items-center justify-between relative"
            >
                <div class="flex items-center space-x-2">
                    <span id="file-status">editr.txt</span>
                </div>

                <span
                    class="absolute left-1/2 -translate-x-1/2 text-gray-200 font-bold text-sm"
                    >editr</span
                >

                <div class="flex items-center space-x-2">
                    <button
                        id="menu-button"
                        class="ml-auto p-1 rounded-sm hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-gray-500"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-4 w-4"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path
                                d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"
                            />
                        </svg>
                    </button>
                </div>
            </div>

            <textarea
                id="editor"
                spellcheck="false"
                class="flex-1 w-full p-4 md:p-6 bg-gray-800 text-gray-200 text-sm md:text-base leading-relaxed custom-scrollbar"
            ></textarea>
        </div>

        <div
            id="context-menu"
            class="absolute z-50 hidden bg-gray-700 text-sm rounded-lg shadow-2xl overflow-hidden min-w-[200px] border border-gray-600 fade-in"
        >
            <ul id="menu-list" class="divide-y divide-gray-600"></ul>
        </div>

        <input type="file" id="file-input" class="hidden" />
        <input
            type="file"
            id="expander-rules-input"
            class="hidden"
            accept=".txt"
        />

        <div
            id="message-box"
            class="fixed hidden bottom-4 left-1/2 -translate-x-1/2 bg-gray-900 text-gray-200 px-4 py-2 rounded-lg shadow-lg"
        >
            Message
        </div>

        <script>
            // Add this code to register the Service Worker for PWA functionality
            if ("serviceWorker" in navigator) {
                window.addEventListener("load", () => {
                    navigator.serviceWorker
                        .register("./sw.js")
                        .then((registration) => {
                            console.log(
                                "Service Worker registered with scope:",
                                registration.scope,
                            );

                            // Check for updates
                            registration.addEventListener("updatefound", () => {
                                console.log("Service Worker update found");
                            });
                        })
                        .catch((err) => {
                            console.log(
                                "Service Worker registration failed:",
                                err,
                            );
                        });
                });
            }

            // Global variables for the elements
            const editorContainer = document.getElementById("editor-container");
            const editor = document.getElementById("editor");
            const contextMenu = document.getElementById("context-menu");
            const menuList = document.getElementById("menu-list");
            const messageBox = document.getElementById("message-box");
            const fileStatus = document.getElementById("file-status");
            const fileInput = document.getElementById("file-input");
            const expanderRulesInput = document.getElementById(
                "expander-rules-input",
            );
            const menuButton = document.getElementById("menu-button");

            // State management with localStorage
            const STORAGE_KEY = "fluxbox-editor-buffers";
            const CALENDAR_BUFFER_ID = "calendar-buffer";
            const CALCULATOR_BUFFER_ID = "calculator-buffer";
            const EXPANDER_BUFFER_ID = "expander-buffer"; // New constant for the expander buffer

            let bufferIds = []; // Stores the ordered IDs of the buffers
            let currentBufferId = null;
            let calendarDate = new Date();
            // A reference to the currently opened file handle for direct saving
            let fileHandle = null;

            // --- Expander Rules Format ---
            // This text editor supports a text expansion feature. You can create your own
            // custom shortcuts and import them from a .txt file. The file must be in valid
            // JSON format.
            //
            // Each entry is a "key: value" pair.
            // - The `key` is the shortcut (e.g., "sig").
            // - The `value` is the text to expand to (e.g., "Best regards,\n- Your Name").
            //
            // Example format for the .txt file:
            // {
            //   "e": "you@email.com",
            //   "p": "555-555-5555"
            // }
            //
            // Note: The built-in shortcuts like 'd' will still work even if not in the imported file.
            // -----------------------------
            let expanderRules = {
                d: () => {
                    const d = new Date();
                    const yyyy = d.getFullYear();
                    const mm = String(d.getMonth() + 1).padStart(2, "0");
                    const dd = String(d.getDate()).padStart(2, "0");
                    return `${yyyy}${mm}${dd}`;
                },
                sig: "Best regards,\n- Your Name",
            };

            // Context menu items with their actions
            const menuActions = [
                {
                    text: "New",
                    action: () => newFile(),
                    shortcut: "Ctrl + N",
                    buffers: ["all"],
                },
                {
                    text: "Open",
                    action: () => openFile(),
                    shortcut: "Ctrl + O",
                    buffers: ["all"],
                },
                {
                    text: "Save",
                    action: () => saveFile(),
                    shortcut: "Ctrl + S",
                    buffers: ["all"],
                },
                {
                    text: "Close",
                    action: () => closeFile(),
                    shortcut: "Ctrl + W",
                    buffers: ["all"],
                },
                { text: "---", buffers: ["all"] }, // Separator
                {
                    text: "Pin/Unpin",
                    action: () => togglePin(),
                    shortcut: "Ctrl + P",
                    buffers: ["all"],
                },
                { text: "---", buffers: ["all"] }, // Separator
                {
                    text: "Open URL",
                    action: () => openURL(),
                    shortcut: "Ctrl + U",
                    buffers: ["all"],
                },
                { text: "---", buffers: ["all"] }, // Separator
                {
                    text: "Calculator",
                    action: () => newCalculator(),
                    shortcut: "Ctrl + Shift + M",
                    buffers: ["all"],
                },
                {
                    text: "Calendar",
                    action: () => newCalendar(),
                    shortcut: "Ctrl + Shift + C",
                    buffers: ["all"],
                },
                { text: "---", buffers: ["all"] }, // Separator
                {
                    text: "Expander",
                    action: () => newExpanderBuffer(),
                    shortcut: "Ctrl + E",
                    buffers: ["all"],
                },
                {
                    text: "Import",
                    action: () => importExpanderRules(),
                    buffers: [EXPANDER_BUFFER_ID],
                },
                {
                    text: "Export",
                    action: () => exportExpanderRules(),
                    buffers: [EXPANDER_BUFFER_ID],
                },
                { text: "---", buffers: ["all"] }, // Separator
                {
                    text: "Previous",
                    action: () => switchBuffer(-1),
                    shortcut: "Ctrl + ←",
                    buffers: ["all"],
                },
                {
                    text: "Next",
                    action: () => switchBuffer(1),
                    shortcut: "Ctrl + →",
                    buffers: ["all"],
                },
            ];

            // Function to create and show the context menu
            function showContextMenu(x, y) {
                menuList.innerHTML = "";

                menuActions.forEach((item) => {
                    // Check if the item should be shown for the current buffer
                    const showItem =
                        item.buffers &&
                        (item.buffers.includes("all") ||
                            item.buffers.includes(currentBufferId));

                    if (!showItem) {
                        return; // Skip this item
                    }

                    if (item.text === "---") {
                        const separator = document.createElement("li");
                        separator.className =
                            "my-1 mx-2 border-t border-gray-600";
                        menuList.appendChild(separator);
                    } else {
                        const listItem = document.createElement("li");
                        listItem.className =
                            "flex justify-between items-center px-4 py-2 hover:bg-gray-600 cursor-pointer transition-colors";

                        // Update the pin/unpin text dynamically
                        if (item.text.includes("Pin/Unpin")) {
                            const currentFile = JSON.parse(
                                localStorage.getItem(currentBufferId),
                            );
                            const text =
                                currentFile && currentFile.isPinned
                                    ? "Unpin"
                                    : "Pin";
                            listItem.innerHTML = `
                                <span>${text}</span>
                                ${item.shortcut ? `<span class="text-xs text-gray-400 ml-4">${item.shortcut}</span>` : ""}
                            `;
                        } else {
                            listItem.innerHTML = `
                                <span>${item.text}</span>
                                ${item.shortcut ? `<span class="text-xs text-gray-400 ml-4">${item.shortcut}</span>` : ""}
                            `;
                        }

                        // Disable switching buttons if there's only one buffer
                        if (
                            (item.text === "Previous" ||
                                item.text === "Next") &&
                            bufferIds.length <= 1
                        ) {
                            listItem.classList.add(
                                "opacity-50",
                                "cursor-not-allowed",
                            );
                            listItem.onclick = (e) => {
                                e.stopPropagation();
                                hideContextMenu();
                            };
                        } else {
                            listItem.onclick = (e) => {
                                e.stopPropagation();
                                item.action();
                                hideContextMenu();
                            };
                        }

                        menuList.appendChild(listItem);
                    }
                });

                // Position the menu, adjusting for screen edges
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                contextMenu.style.display = "block";
                const menuWidth = contextMenu.offsetWidth;
                const menuHeight = contextMenu.offsetHeight;

                let finalX = x;
                let finalY = y;

                if (x + menuWidth > viewportWidth) {
                    finalX = viewportWidth - menuWidth - 5;
                }
                if (y + menuHeight > viewportHeight) {
                    finalY = y - menuHeight - 5;
                }
                if (finalY < 0) finalY = 5;

                contextMenu.style.left = `${finalX}px`;
                contextMenu.style.top = `${finalY}px`;
            }

            // Function to hide the context menu
            function hideContextMenu() {
                contextMenu.style.display = "none";
            }

            // Function to show a temporary message
            function showMessage(text) {
                messageBox.textContent = text;
                messageBox.classList.remove("hidden");
                setTimeout(() => {
                    messageBox.classList.add("hidden");
                }, 2000);
            }

            // Saves all buffers to localStorage
            function saveBuffers() {
                try {
                    const existingBuffers = bufferIds.filter((id) =>
                        localStorage.getItem(id),
                    );
                    const buffers = existingBuffers.map((id) =>
                        JSON.parse(localStorage.getItem(id)),
                    );
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(buffers));
                    saveExpanderRulesBuffer();
                } catch (e) {
                    console.error("Could not save buffers to localStorage:", e);
                    showMessage("Error saving files. Check console.");
                }
            }

            // Loads all buffers from localStorage
            function loadBuffers() {
                try {
                    const storedBuffers = localStorage.getItem(STORAGE_KEY);
                    if (storedBuffers) {
                        const buffers = JSON.parse(storedBuffers);
                        buffers.forEach((buffer) => {
                            localStorage.setItem(
                                buffer.id,
                                JSON.stringify(buffer),
                            );
                        });
                        const pinnedIds = buffers
                            .filter((b) => b.isPinned)
                            .map((b) => b.id);
                        const unpinnedIds = buffers
                            .filter((b) => !b.isPinned)
                            .map((b) => b.id);
                        bufferIds = [...pinnedIds, ...unpinnedIds];

                        if (bufferIds.length > 0) {
                            currentBufferId = bufferIds[0];
                        }
                        loadExpanderRulesFromBuffer();
                    }
                } catch (e) {
                    console.error(
                        "Could not parse buffers from localStorage:",
                        e,
                    );
                    localStorage.removeItem(STORAGE_KEY);
                    bufferIds = [];
                    currentBufferId = null;
                }
            }

            // Updates the UI to match the current buffer
            function updateUI() {
                if (currentBufferId === null) {
                    editor.value = "";
                    fileStatus.textContent = "No open files";
                    // Reset fileHandle when no file is open
                    fileHandle = null;
                    return;
                }

                const currentFile = JSON.parse(
                    localStorage.getItem(currentBufferId),
                );
                if (!currentFile) {
                    console.error("Current buffer not found in localStorage.");
                    newFile();
                    return;
                }

                editor.value = currentFile.content;
                const currentBufferIndex = bufferIds.indexOf(currentBufferId);
                const pinIndicator = currentFile.isPinned ? " 📌" : "";
                fileStatus.textContent = `${currentFile.name}${pinIndicator} (${currentBufferIndex + 1}/${bufferIds.length})`;
                showMessage(`Switched to: ${currentFile.name}`);

                // Update the fileHandle if the buffer has one
                if (currentFile.fileHandle) {
                    // This is a placeholder as you can't store a FileHandle in localStorage
                    // I will update the openFile logic to directly set the fileHandle
                    // to the global variable.
                } else {
                    fileHandle = null;
                }
            }

            // Main actions
            function newFile() {
                const newId = `buffer-${Date.now()}`;
                const newFileObject = {
                    id: newId,
                    name: `editr-${bufferIds.length + 1}.txt`,
                    content: "",
                    isPinned: false,
                    fileHandle: null, // New field to indicate if it's a local file
                };
                localStorage.setItem(newId, JSON.stringify(newFileObject));
                bufferIds.push(newId);
                currentBufferId = newId;
                // Reset fileHandle when creating a new file
                fileHandle = null;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            async function openFile() {
                // Use File System Access API if available
                if ("showOpenFilePicker" in window) {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [
                                {
                                    description: "Text Files",
                                    accept: {
                                        "text/plain": [
                                            ".txt",
                                            ".md",
                                            ".html",
                                            ".js",
                                            ".css",
                                            ".json",
                                            ".bat",
                                            ".ps1",
                                            ".sh",
                                            ".csv",
                                            ".tsv",
                                            ".log",
                                            ".xml",
                                        ],
                                    },
                                },
                            ],
                        });
                        fileHandle = handle;
                        const file = await fileHandle.getFile();

                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const newId = `buffer-${Date.now()}`;
                            const newFileObject = {
                                id: newId,
                                name: file.name,
                                content: event.target.result,
                                isPinned: false,
                                fileHandle: "exists", // A simple flag to indicate it came from a file handle
                            };
                            localStorage.setItem(
                                newId,
                                JSON.stringify(newFileObject),
                            );
                            bufferIds.push(newId);
                            currentBufferId = newId;
                            saveBuffers();
                            updateUI();
                            editor.focus();
                            showMessage(`Opened file: ${file.name}`);
                        };
                        reader.readAsText(file);
                    } catch (e) {
                        if (e.name === "AbortError") {
                            showMessage("Open operation cancelled.");
                        } else {
                            console.error("Error opening file:", e);
                            showMessage("Error opening file. Check console.");
                        }
                    }
                } else {
                    // Fallback to the old method for browsers that don't support the API
                    fileInput.click();
                }
            }

            // Event listener for the fallback file input change
            fileInput.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const fileName = file.name.toLowerCase();
                const supportedExtensions = [
                    ".txt",
                    ".md",
                    ".html",
                    ".js",
                    ".css",
                    ".json",
                    ".bat",
                    ".ps1",
                    ".sh",
                    ".csv",
                    ".tsv",
                    ".log",
                    ".xml",
                ];
                const isSupported = supportedExtensions.some((ext) =>
                    fileName.endsWith(ext),
                );
                if (!isSupported) {
                    showMessage("Unsupported file type.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    const newId = `buffer-${Date.now()}`;
                    const newFileObject = {
                        id: newId,
                        name: file.name,
                        content: event.target.result,
                        isPinned: false,
                        fileHandle: null, // No file handle for this method
                    };
                    localStorage.setItem(newId, JSON.stringify(newFileObject));
                    bufferIds.push(newId);
                    currentBufferId = newId;
                    saveBuffers();
                    updateUI();
                    editor.focus();
                    showMessage(`Opened file: ${file.name}`);
                };
                reader.readAsText(file);
            });

            async function saveFile() {
                if (currentBufferId === null) {
                    showMessage("No file to save.");
                    return;
                }
                const currentFile = JSON.parse(
                    localStorage.getItem(currentBufferId),
                );
                const content = editor.value;

                try {
                    // Use File System Access API
                    if ("showSaveFilePicker" in window) {
                        let handle = fileHandle;
                        // If there is no existing file handle, open a save dialog
                        if (!handle) {
                            handle = await window.showSaveFilePicker({
                                suggestedName: currentFile.name,
                                types: [
                                    {
                                        description: "Text File",
                                        accept: { "text/plain": [".txt"] },
                                    },
                                ],
                            });
                            // Store the handle for future saves
                            fileHandle = handle;
                            // Update the buffer to reflect that it's now tied to a file
                            currentFile.fileHandle = "exists";
                            localStorage.setItem(
                                currentBufferId,
                                JSON.stringify(currentFile),
                            );
                            updateUI();
                        }
                        const writable = await handle.createWritable();
                        await writable.write(content);
                        await writable.close();
                        showMessage("File saved successfully.");
                    } else {
                        // Fallback for browsers that don't support the API
                        const blob = new Blob([content], {
                            type: "text/plain",
                        });
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(blob);
                        link.download = currentFile.name;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        showMessage("File saved.");
                    }
                } catch (e) {
                    if (e.name === "AbortError") {
                        showMessage("Save operation cancelled.");
                    } else {
                        console.error("Error saving file:", e);
                        showMessage("Error saving file. Check console.");
                    }
                }
            }

            function closeFile() {
                if (currentBufferId === null) {
                    showMessage("No file to close.");
                    return;
                }

                const index = bufferIds.indexOf(currentBufferId);
                localStorage.removeItem(currentBufferId);
                bufferIds.splice(index, 1);
                // Reset file handle when closing the file
                fileHandle = null;

                if (bufferIds.length === 0) {
                    currentBufferId = null;
                    editor.value = "";
                    newFile();
                } else {
                    const nextIndex = Math.max(0, index - 1);
                    currentBufferId = bufferIds[nextIndex];
                    updateUI();
                }
                saveBuffers();
            }

            function switchBuffer(direction) {
                if (bufferIds.length <= 1) {
                    showMessage("No other files to switch to.");
                    return;
                }
                const currentIndex = bufferIds.indexOf(currentBufferId);
                const nextIndex =
                    (currentIndex + direction + bufferIds.length) %
                    bufferIds.length;
                currentBufferId = bufferIds[nextIndex];
                updateUI();
            }

            function togglePin() {
                if (currentBufferId === null) {
                    showMessage("No file to pin/unpin.");
                    return;
                }

                const currentFile = JSON.parse(
                    localStorage.getItem(currentBufferId),
                );
                currentFile.isPinned = !currentFile.isPinned;
                localStorage.setItem(
                    currentBufferId,
                    JSON.stringify(currentFile),
                );

                const currentIndex = bufferIds.indexOf(currentBufferId);
                bufferIds.splice(currentIndex, 1);

                if (currentFile.isPinned) {
                    bufferIds.unshift(currentBufferId);
                    showMessage(`Pinned: ${currentFile.name}`);
                } else {
                    let firstUnpinnedIndex = bufferIds.length;
                    for (let i = 0; i < bufferIds.length; i++) {
                        const buffer = JSON.parse(
                            localStorage.getItem(bufferIds[i]),
                        );
                        if (!buffer.isPinned) {
                            firstUnpinnedIndex = i;
                            break;
                        }
                    }
                    bufferIds.splice(firstUnpinnedIndex, 0, currentBufferId);
                    showMessage(`Unpinned: ${currentFile.name}`);
                }

                saveBuffers();
                updateUI();
            }

            function selectAll() {
                editor.select();
                showMessage("All text selected.");
            }

            // --- URL opening function
            function openURL() {
                // Get the current line's text
                const cursorPosition = editor.selectionStart;
                const text = editor.value;
                const lineStart =
                    text.lastIndexOf("\n", cursorPosition - 1) + 1;
                const lineEnd = text.indexOf("\n", cursorPosition);
                const currentLine = text
                    .substring(
                        lineStart,
                        lineEnd === -1 ? text.length : lineEnd,
                    )
                    .trim();

                // Simple regex to check for a URL.
                // It looks for a string starting with http://, https://, or www.
                const urlRegex = /^(https?:\/\/|www\.)\S+$/i;
                if (urlRegex.test(currentLine)) {
                    // Prepend http:// if it's not already there for a clean open
                    const url = currentLine.startsWith("http")
                        ? currentLine
                        : `http://${currentLine}`;
                    window.open(url, "_blank");
                    showMessage("Opening URL in new tab.");
                } else {
                    showMessage("No valid URL found on the current line.");
                }
            }

            // --- Custom Buffer Logic: Calculator and Calendar ---

            function newCalculator() {
                if (bufferIds.includes(CALCULATOR_BUFFER_ID)) {
                    currentBufferId = CALCULATOR_BUFFER_ID;
                    updateUI();
                    return;
                }
                const newFileObject = {
                    id: CALCULATOR_BUFFER_ID,
                    name: "Calculator",
                    content:
                        "--- Simple Calculator ---\nType a mathematical expression and press Enter.\n\n",
                    isPinned: false,
                };
                localStorage.setItem(
                    CALCULATOR_BUFFER_ID,
                    JSON.stringify(newFileObject),
                );
                bufferIds.push(CALCULATOR_BUFFER_ID);
                currentBufferId = CALCULATOR_BUFFER_ID;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            function generateCalendarString(date) {
                const monthNames = [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                ];
                const dayNames = ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"];

                const year = date.getFullYear();
                const month = date.getMonth();
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0).getDate();
                const startDay = (firstDay.getDay() + 6) % 7;

                let output = `[<] Previous Month     [>] Next Month\n\n`;
                output += `        ${monthNames[month]} ${year}\n`;
                output += `  ${dayNames.join("  ")}\n`;
                output += `--------------------------\n`;

                let day = 1;
                let currentLine = "";
                for (let i = 0; i < 7; i++) {
                    if (i < startDay) {
                        currentLine += "    ";
                    } else {
                        const dayString = day.toString().padStart(2, " ");
                        currentLine += `${dayString}  `;
                        day++;
                    }
                }
                output += currentLine.trim() + "\n";

                while (day <= lastDay) {
                    currentLine = "";
                    for (let i = 0; i < 7 && day <= lastDay; i++) {
                        const dayString = day.toString().padStart(2, " ");
                        currentLine += `${dayString}  `;
                        day++;
                    }
                    output += currentLine.trim() + "\n";
                }

                return output;
            }

            function newCalendar() {
                if (bufferIds.includes(CALENDAR_BUFFER_ID)) {
                    currentBufferId = CALENDAR_BUFFER_ID;
                    updateUI();
                    return;
                }
                const newFileObject = {
                    id: CALENDAR_BUFFER_ID,
                    name: "Calendar",
                    content: generateCalendarString(calendarDate),
                    isPinned: false,
                };
                localStorage.setItem(
                    CALENDAR_BUFFER_ID,
                    JSON.stringify(newFileObject),
                );
                bufferIds.push(CALENDAR_BUFFER_ID);
                currentBufferId = CALENDAR_BUFFER_ID;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            // --- New Expander Rules Buffer Logic ---

            function newExpanderBuffer() {
                if (bufferIds.includes(EXPANDER_BUFFER_ID)) {
                    currentBufferId = EXPANDER_BUFFER_ID;
                    updateUI();
                    return;
                }

                // Generate content from the current rules
                const initialContent = JSON.stringify(expanderRules, null, 2);

                const newFileObject = {
                    id: EXPANDER_BUFFER_ID,
                    name: "Expander Rules",
                    content: `
// Edit your text expansion rules here in JSON format.
// Save this buffer to apply changes.
// Example:
// {
//   "e": "you@email.com",
//   "p": "(555) 555-5555"
// }
// Note: Add , to end of each expander line except last.
// Note: 'd' reserved for YYYYMMDD.
// -------------------------------------------------------------
${initialContent}
`.trim(),
                    isPinned: false,
                };
                localStorage.setItem(
                    EXPANDER_BUFFER_ID,
                    JSON.stringify(newFileObject),
                );
                bufferIds.push(EXPANDER_BUFFER_ID);
                currentBufferId = EXPANDER_BUFFER_ID;
                saveBuffers();
                updateUI();
                editor.focus();
            }

            function saveExpanderRulesBuffer() {
                const expanderBuffer = JSON.parse(
                    localStorage.getItem(EXPANDER_BUFFER_ID),
                );
                if (expanderBuffer) {
                    try {
                        const newRules = JSON.parse(
                            expanderBuffer.content.replace(/\/\/.*/g, ""),
                        );
                        for (const key in newRules) {
                            if (typeof expanderRules[key] === "function") {
                            } else {
                                expanderRules[key] = newRules[key];
                            }
                        }
                        showMessage("Expander rules updated from buffer.");
                    } catch (e) {
                        showMessage(
                            "Error: The Expander Rules buffer is not valid JSON.",
                        );
                    }
                }
            }

            function loadExpanderRulesFromBuffer() {
                const expanderBuffer = JSON.parse(
                    localStorage.getItem(EXPANDER_BUFFER_ID),
                );
                if (expanderBuffer) {
                    try {
                        const newRules = JSON.parse(
                            expanderBuffer.content.replace(/\/\/.*/g, ""),
                        );
                        expanderRules = { ...expanderRules, ...newRules };
                    } catch (e) {}
                }
            }

            // Expander rules import/export logic
            function importExpanderRules() {
                expanderRulesInput.click();
            }

            function exportExpanderRules() {
                const rulesToExport = {};
                for (const key in expanderRules) {
                    if (typeof expanderRules[key] !== "function") {
                        rulesToExport[key] = expanderRules[key];
                    }
                }
                const content = JSON.stringify(rulesToExport, null, 2);
                const blob = new Blob([content], { type: "text/plain" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "expander_rules.txt";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage("Expander rules saved to expander_rules.txt.");
            }

            // Event listener for importing expander rules
            expanderRulesInput.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedRules = JSON.parse(event.target.result);
                        // Clear existing rules and add 'd' function before adding new ones
                        expanderRules = {
                            d: () => {
                                const d = new Date();
                                const yyyy = d.getFullYear();
                                const mm = String(d.getMonth() + 1).padStart(
                                    2,
                                    "0",
                                );
                                const dd = String(d.getDate()).padStart(2, "0");
                                return `${yyyy}${mm}${dd}`;
                            },
                        };
                        expanderRules = { ...expanderRules, ...importedRules };

                        // Update the Expander Rules buffer with the new content
                        const expanderBuffer = JSON.parse(
                            localStorage.getItem(EXPANDER_BUFFER_ID),
                        );
                        if (expanderBuffer) {
                            const newContent = JSON.stringify(
                                importedRules,
                                null,
                                2,
                            );
                            expanderBuffer.content = `
// Edit your text expansion rules here in JSON format.
// Save this buffer to apply changes.
// Example:
// {
//   "e": "you@email.com",
//   "p": "(555) 555-5555"
// }
// Note: Add , to end of each expander line except last.
// Note: 'd' reserved for YYYYMMDD.
// -------------------------------------------------------------
${newContent}
`.trim();
                            localStorage.setItem(
                                EXPANDER_BUFFER_ID,
                                JSON.stringify(expanderBuffer),
                            );
                            // Only update the editor if it's the current buffer
                            if (currentBufferId === EXPANDER_BUFFER_ID) {
                                editor.value = expanderBuffer.content;
                                updateUI();
                            }
                        }

                        showMessage(
                            "Expander rules imported successfully from .txt file.",
                        );
                    } catch (error) {
                        showMessage(
                            "Error: Could not import rules. The .txt file is not in valid JSON format.",
                        );
                    }
                };
                reader.readAsText(file);
            });

            // Event listener for the text expander functionality
            editor.addEventListener("input", () => {
                const cursorPosition = editor.selectionStart;
                const text = editor.value;

                if (cursorPosition >= 2) {
                    const triggerPrefix = text.substring(
                        cursorPosition - 2,
                        cursorPosition,
                    );
                    if (
                        triggerPrefix.startsWith(".") &&
                        expanderRules[triggerPrefix.substring(1)]
                    ) {
                        const rule = expanderRules[triggerPrefix.substring(1)];
                        const expansion =
                            typeof rule === "function" ? rule() : rule;

                        const newText =
                            text.substring(0, cursorPosition - 2) +
                            expansion +
                            text.substring(cursorPosition);
                        editor.value = newText;

                        const newCursorPosition =
                            cursorPosition - 2 + expansion.length;
                        editor.selectionStart = newCursorPosition;
                        editor.selectionEnd = newCursorPosition;

                        if (currentBufferId !== null) {
                            const currentFile = JSON.parse(
                                localStorage.getItem(currentBufferId),
                            );
                            currentFile.content = newText;
                            localStorage.setItem(
                                currentBufferId,
                                JSON.stringify(currentFile),
                            );
                        }
                    }
                }
            });

            // Function to update the line highlight
            const updateLineHighlight = () => {
                const cursorPosition = editor.selectionStart;
                const textBeforeCursor = editor.value.substring(
                    0,
                    cursorPosition,
                );
                const lineNumber = (textBeforeCursor.match(/\n/g) || []).length;
                const computedStyle = window.getComputedStyle(editor);
                const lineHeight = parseFloat(computedStyle.lineHeight);
                const paddingTop = parseFloat(computedStyle.paddingTop);
                const highlightY = lineNumber * lineHeight + paddingTop;
                editor.style.setProperty("--highlight-y", `${highlightY}px`);
            };

            // Event listeners
            document.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY);
            });

            menuButton.addEventListener("click", (e) => {
                e.stopPropagation();
                const rect = menuButton.getBoundingClientRect();
                const menuWidth = contextMenu.offsetWidth;
                const x = rect.right - menuWidth;
                const y = rect.bottom;
                showContextMenu(x, y);
            });

            document.addEventListener("click", (e) => {
                if (
                    !contextMenu.contains(e.target) &&
                    e.target !== menuButton &&
                    !menuButton.contains(e.target)
                ) {
                    hideContextMenu();
                }
            });

            editorContainer.addEventListener("dragover", (e) => {
                e.preventDefault();
                editorContainer.classList.add(
                    "border-4",
                    "border-blue-500",
                    "border-dashed",
                );
            });

            editorContainer.addEventListener("dragleave", (e) => {
                editorContainer.classList.remove(
                    "border-4",
                    "border-blue-500",
                    "border-dashed",
                );
            });

            editorContainer.addEventListener("drop", (e) => {
                e.preventDefault();
                editorContainer.classList.remove(
                    "border-4",
                    "border-blue-500",
                    "border-dashed",
                );

                const file = e.dataTransfer.files[0];
                if (!file) {
                    showMessage("No file was dropped.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    const newId = `buffer-${Date.now()}`;
                    const newFileObject = {
                        id: newId,
                        name: file.name,
                        content: event.target.result,
                    };
                    localStorage.setItem(newId, JSON.stringify(newFileObject));
                    bufferIds.push(newId);
                    currentBufferId = newId;
                    saveBuffers();
                    updateUI();
                    editor.focus();
                    showMessage(`Opened file: ${file.name}`);
                };
                reader.readAsText(file);
            });

            editor.addEventListener("input", () => {
                if (currentBufferId !== null) {
                    const currentFile = JSON.parse(
                        localStorage.getItem(currentBufferId),
                    );
                    currentFile.content = editor.value;
                    localStorage.setItem(
                        currentBufferId,
                        JSON.stringify(currentFile),
                    );
                    saveBuffers();
                }
            });

            editor.addEventListener("input", (e) => {
                const pairings = {
                    "(": ")",
                    "[": "]",
                    "{": "}",
                    '"': '"',
                    "'": "'",
                    "`": "`",
                };
                const cursorPosition = editor.selectionStart;
                const text = editor.value;
                const char = text.charAt(cursorPosition - 1);

                if (pairings[char]) {
                    const newText =
                        text.substring(0, cursorPosition) +
                        pairings[char] +
                        text.substring(cursorPosition);
                    editor.value = newText;
                    editor.selectionStart = cursorPosition;
                    editor.selectionEnd = cursorPosition;
                }
            });

            editor.addEventListener("input", updateLineHighlight);
            editor.addEventListener("click", updateLineHighlight);
            editor.addEventListener("scroll", updateLineHighlight);

            editor.addEventListener("keydown", (e) => {
                if (
                    e.key === "ArrowUp" ||
                    e.key === "ArrowDown" ||
                    e.key === "ArrowLeft" ||
                    e.key === "ArrowRight"
                ) {
                    setTimeout(updateLineHighlight, 0);
                }

                const cursorPosition = editor.selectionStart;
                const text = editor.value;
                const lineStart =
                    text.lastIndexOf("\n", cursorPosition - 1) + 1;
                const line = text.substring(lineStart, cursorPosition);

                if (currentBufferId === EXPANDER_BUFFER_ID) {
                    if (e.key === "Enter") {
                        saveExpanderRulesBuffer();
                    }
                }

                if (
                    e.key === "Enter" &&
                    currentBufferId === CALCULATOR_BUFFER_ID
                ) {
                    e.preventDefault();
                    try {
                        const result = Function(
                            `'use strict'; return (${line})`,
                        )();
                        editor.value += `\n= ${result}\n`;
                    } catch (err) {
                        editor.value += `\n= Error: Invalid expression\n`;
                    }
                    editor.scrollTop = editor.scrollHeight;
                }

                if (currentBufferId === CALENDAR_BUFFER_ID) {
                    if (e.key === "ArrowLeft") {
                        e.preventDefault();
                        calendarDate.setMonth(calendarDate.getMonth() - 1);
                        const newContent = generateCalendarString(calendarDate);
                        const currentFile = JSON.parse(
                            localStorage.getItem(CALENDAR_BUFFER_ID),
                        );
                        currentFile.content = newContent;
                        localStorage.setItem(
                            CALENDAR_BUFFER_ID,
                            JSON.stringify(currentFile),
                        );
                        editor.value = newContent;
                        showMessage("Previous Month");
                    } else if (e.key === "ArrowRight") {
                        e.preventDefault();
                        calendarDate.setMonth(calendarDate.getMonth() + 1);
                        const newContent = generateCalendarString(calendarDate);
                        const currentFile = JSON.parse(
                            localStorage.getItem(CALENDAR_BUFFER_ID),
                        );
                        currentFile.content = newContent;
                        localStorage.setItem(
                            CALENDAR_BUFFER_ID,
                            JSON.stringify(currentFile),
                        );
                        editor.value = newContent;
                        showMessage("Next Month");
                    }
                }

                if (e.key === "Tab") {
                    e.preventDefault();
                    const start = editor.selectionStart;
                    const end = editor.selectionEnd;
                    editor.value =
                        text.substring(0, start) + "    " + text.substring(end);
                    editor.selectionStart = editor.selectionEnd = start + 4;
                }

                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case "n":
                            e.preventDefault();
                            newFile();
                            break;
                        case "o":
                            e.preventDefault();
                            openFile();
                            break;
                        case "s":
                            e.preventDefault();
                            saveFile();
                            break;
                        case "w":
                            e.preventDefault();
                            closeFile();
                            break;
                        case "p":
                            e.preventDefault();
                            togglePin();
                            break;
                        case "u":
                            e.preventDefault();
                            openURL();
                            break;
                        case "m":
                            if (e.shiftKey) {
                                e.preventDefault();
                                newCalculator();
                            }
                            break;
                        case "c":
                            if (e.shiftKey) {
                                e.preventDefault();
                                newCalendar();
                            }
                            break;
                        case "e":
                            e.preventDefault();
                            newExpanderBuffer();
                            break;
                        case "ArrowLeft":
                            e.preventDefault();
                            switchBuffer(-1);
                            break;
                        case "ArrowRight":
                            e.preventDefault();
                            switchBuffer(1);
                            break;
                    }
                }
            });

            window.onload = () => {
                console.log("Initializing editor...");
                loadBuffers();
                if (bufferIds.length === 0) {
                    console.log("No buffers found, creating new file");
                    newFile();
                } else {
                    console.log("Loaded existing buffers, updating UI");
                    updateUI();
                }
                editor.focus();
                updateLineHighlight();

                setInterval(() => {
                    if (currentBufferId !== null) {
                        saveBuffers();
                    }
                }, 30000);
            };
        </script>
    </body>
</html>
