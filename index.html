<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>editr</title>
        <link rel="manifest" href="manifest.json" />
        <meta name="theme-color" content="#44475a" />
        <link
            rel="apple-touch-icon"
            href="https://placehold.co/192x192/282a36/f8f8f2?text=e"
        />
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'><rect width='16' height='16' fill='%23282828'/><text x='8' y='12' font-family='monospace' font-size='12' fill='%23ff8c00' text-anchor='middle'>e</text></svg>"
        />
        <style>
            /* --- Base Styles & Theme --- */
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            :root {
                --bg-main: #1a1a1a;
                --bg-content: #282828;
                --bg-ui: #333333;
                --bg-ui-hover: #444444;
                --text-main: #e0e0e0;
                --text-dark: #111111;
                --border-color: #555555;
                --accent-orange: #ff8c00;
                --accent-orange-dark: #cc7000;
                --accent-orange-transparent: rgba(255, 140, 0, 0.2);
            }

            body {
                font-family: "Segoe UI", "Roboto", sans-serif;
                background: var(--bg-main);
                color: var(--text-main);
                height: 100vh;
                position: relative;
                transition: background 0.3s ease;
                overflow: hidden; /* Prevent body scrollbars */
            }

            /* --- Main Layout --- */
            #mainContent {
                display: flex;
                height: 100vh;
            }

            #editor,
            #previewPane {
                height: 100%;
                width: 100%;
                transition: width 0.3s ease;
            }

            /* Split view mode */
            body.split-view-active #editor {
                width: 50%;
            }
            body.split-view-active #previewPane {
                width: 50%;
            }

            #editor {
                border: none;
                outline: none;
                padding: 20px;
                font-family: monospace, "Courier New";
                font-size: 14px;
                line-height: 1.5;
                background: var(--bg-content);
                color: var(--text-main);
                border-left: 1px solid var(--border-color);
                resize: none;
                white-space: pre-wrap; /* Default word wrap is on */
                word-wrap: break-word;
            }

            #editor::selection {
                background-color: var(--accent-orange);
                color: var(--text-dark);
            }

            #editor.no-wrap {
                white-space: pre;
                word-wrap: normal;
                overflow-x: auto;
            }

            #editor.drag-over {
                border: 3px dashed var(--accent-orange);
                background: var(--accent-orange-transparent);
            }

            #fileInput {
                display: none;
            }

            /* --- Markdown Preview Pane --- */
            #previewPane {
                padding: 20px;
                overflow-y: auto;
                background: var(--bg-content);
                border-left: 1px solid #000;
            }

            /* --- Light Mode --- */
            body.light-mode {
                background: #808080;
                color: #000;
            }
            body.light-mode #editor {
                background: #f0f0f0;
                color: #000;
                border-left: none;
            }
            body.light-mode #editor::selection {
                background-color: #0078d7;
                color: white;
            }
            body.light-mode #editor.drag-over {
                border: 3px dashed #0078d7;
                background: rgba(0, 120, 215, 0.1);
            }
            body.light-mode #previewPane {
                background: #f9f9f9;
                color: #000;
                border-left: 1px solid #ddd;
            }

            /* --- Grid View Styles --- */
            #gridContainer {
                width: 100%;
                height: 100vh;
                display: flex;
                flex-direction: column;
                background: var(--bg-content);
            }

            #gridToolbar {
                padding: 8px;
                background: linear-gradient(to bottom, #4a4a4a, #303030);
                border-bottom: 1px solid #000;
                display: flex;
                gap: 8px;
            }

            #gridToolbar button {
                padding: 4px 8px;
                border: 1px solid var(--border-color);
                background: var(--bg-ui);
                color: var(--text-main);
                cursor: pointer;
                border-radius: 4px;
                font-family: sans-serif;
            }

            #gridToolbar button:hover {
                background: var(--bg-ui-hover);
                border-color: #777;
            }

            #gridToolbar button:active {
                background: #555;
            }

            #gridContent {
                flex-grow: 1;
                overflow: auto;
            }

            #gridContent table {
                border-collapse: collapse;
                width: 100%;
                font-size: 14px;
            }

            #gridContent th,
            #gridContent td {
                border: 1px solid var(--border-color);
                padding: 6px 8px;
                min-width: 100px;
            }

            #gridContent th {
                background-color: #333;
                position: sticky;
                top: 0;
                z-index: 10;
            }

            #gridContent td {
                background-color: #2a2a2a;
            }

            #gridContent td.selected {
                outline: 2px solid var(--accent-orange);
                outline-offset: -2px;
            }

            #gridContent td[contenteditable="true"]:focus {
                background-color: #4a4a2a;
            }

            /* Light mode for Grid */
            body.light-mode #gridContainer {
                background: #f0f0f0;
                color: #000;
            }
            body.light-mode #gridToolbar {
                background: #e0e0e0;
                border-bottom: 1px solid #ccc;
            }
            body.light-mode #gridToolbar button {
                background: #f0f0f0;
                border: 1px solid #aaa;
                color: #000;
                border-radius: 4px;
            }
            body.light-mode #gridToolbar button:hover {
                background: #dcdcdc;
            }
            body.light-mode #gridContent th,
            body.light-mode #gridContent td {
                border-color: #ccc;
            }
            body.light-mode #gridContent th {
                background-color: #e8e8e8;
            }
            body.light-mode #gridContent td {
                background-color: #fff;
            }
            body.light-mode #gridContent td.selected {
                outline-color: #0078d7;
            }
            body.light-mode #gridContent td[contenteditable="true"]:focus {
                background-color: #fdfde2;
            }

            /* --- Find/Replace Dialog --- */
            #findReplaceDialog {
                position: fixed;
                top: 15px;
                right: 15px;
                background: #3a3a3a;
                border: 1px solid #000;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
                border-radius: 6px;
                z-index: 2500;
                padding: 8px;
                display: grid;
                grid-template-columns: 1fr auto;
                grid-gap: 5px;
                align-items: center;
                width: 380px;
                font-size: 13px;
            }
            #findReplaceDialog input {
                grid-column: 1 / 2;
                padding: 5px;
                border: 1px solid var(--border-color);
                background: var(--bg-content);
                color: var(--text-main);
                border-radius: 4px;
                font-family: monospace;
            }
            #findReplaceDialog input:focus {
                outline: 1px solid var(--accent-orange);
                border-color: var(--accent-orange);
            }
            #findReplaceDialog .find-controls,
            #findReplaceDialog .replace-controls {
                grid-column: 2 / 3;
                display: flex;
                gap: 4px;
            }
            #findReplaceDialog button {
                padding: 4px 6px;
                border: 1px solid var(--border-color);
                background: var(--bg-ui);
                color: var(--text-main);
                cursor: pointer;
                border-radius: 4px;
            }
            #findReplaceDialog button:hover {
                background: var(--bg-ui-hover);
            }
            #findReplaceDialog #closeFindBtn {
                position: absolute;
                top: -8px;
                right: -8px;
                width: 22px;
                height: 22px;
                border-radius: 50%;
                background: #888;
                color: white;
                border: 1px solid #999;
                line-height: 20px;
                text-align: center;
                font-size: 16px;
            }
            #findReplaceDialog #closeFindBtn:hover {
                background: var(--accent-orange);
                color: var(--text-dark);
            }

            /* Light Mode for Find/Replace */
            body.light-mode #findReplaceDialog {
                background: #f8f8f8;
                border-color: #ccc;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
                color: #000;
                border-radius: 6px;
            }
            body.light-mode #findReplaceDialog input {
                background: #fff;
                color: #000;
                border-color: #ccc;
                border-radius: 4px;
            }
            body.light-mode #findReplaceDialog button {
                background: #e0e0e0;
                border-color: #aaa;
                color: #000;
                border-radius: 4px;
            }
            body.light-mode #findReplaceDialog button:hover {
                background: #d0d0d0;
            }
            body.light-mode #findReplaceDialog #closeFindBtn {
                top: -5px;
                right: -5px;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 1px solid white;
                line-height: 18px;
                font-size: 14px;
            }

            /* --- Mobile Controls --- */
            #mobileControls {
                position: fixed;
                top: 10px;
                right: 10px;
                display: flex;
                gap: 8px;
                z-index: 1000;
                align-items: center;
            }

            #fileNameDisplay {
                display: flex;
                align-items: center;
                padding: 0 12px;
                height: 40px;
                background: var(--bg-content);
                color: var(--text-main);
                border: 1px solid #000;
                border-top: 1px solid var(--border-color);
                font-family: monospace, "Courier New";
                font-size: 14px;
                user-select: none;
                max-width: 250px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                border-radius: 6px;
            }

            #statsDisplay {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 0 12px;
                height: 40px;
                background: var(--bg-content);
                color: var(--text-main);
                border: 1px solid #000;
                border-top: 1px solid var(--border-color);
                font-size: 14px;
                user-select: none;
                border-radius: 6px;
            }

            #statsDisplay span {
                font-family: monospace, "Courier New";
                opacity: 0.8;
            }

            .mobile-btn {
                width: 40px;
                height: 40px;
                background: var(--bg-ui);
                color: var(--text-main);
                border: 1px solid var(--border-color);
                border-radius: 6px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                transition: background 0.2s;
                -webkit-tap-highlight-color: transparent;
                user-select: none;
                touch-action: manipulation;
            }

            .mobile-btn:hover {
                background: var(--bg-ui-hover);
                border-color: #777;
            }

            .mobile-btn:active {
                transform: scale(0.98);
                background: #555;
            }

            /* Light Mode for Top-Right Controls */
            body.light-mode #fileNameDisplay {
                background: #f8f8f8;
                border: 1px solid #bbb;
                color: #000;
                border-radius: 6px;
            }
            body.light-mode #statsDisplay {
                background: #f8f8f8;
                border: 1px solid #bbb;
                color: #000;
                border-radius: 6px;
            }
            body.light-mode .mobile-btn {
                background: #e0e0e0;
                border: 1px solid #ccc;
                color: #000;
                border-radius: 6px;
            }
            body.light-mode .mobile-btn:hover {
                background: #d0d0d0;
            }

            /* --- Context/Mobile Menu --- */
            #contextMenu {
                position: fixed;
                display: none;
                background: linear-gradient(to bottom, #4a4a4a, #303030);
                border: 1px solid #444;
                box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.5);
                border-radius: 6px;
                padding: 4px;
                z-index: 2000;
                font-size: 14px;
                width: 250px;
            }

            .context-menu-item {
                padding: 12px 15px;
                cursor: pointer;
                transition: background 0.1s ease;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                -webkit-tap-highlight-color: transparent;
                user-select: none;
                position: relative;
                color: var(--text-main);
                border-radius: 4px;
            }

            .context-menu-item:hover {
                background: linear-gradient(
                    to right,
                    var(--accent-orange),
                    var(--accent-orange-dark)
                );
                color: #fff;
            }

            .shortcut {
                font-size: 12px;
                opacity: 0.7;
                margin-left: 15px; /* Space between name and shortcut */
            }

            .context-menu-divider {
                height: 2px;
                border: none;
                border-top: 1px solid #222;
                border-bottom: 1px solid #555;
                margin: 4px 0;
            }

            /* --- Context Menu Submenus --- */
            .context-menu-item.has-submenu::after {
                content: "▶";
                font-size: 10px;
                opacity: 0.7;
                transition: transform 0.2s ease;
                margin-left: 10px;
            }
            .submenu {
                position: absolute;
                top: -5px;
                left: 100%;
                width: 100%;
                display: none;
                background: linear-gradient(to bottom, #4a4a4a, #303030);
                border: 1px solid #444;
                box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                padding: 4px;
                z-index: 2001;
            }
            #contextMenu:not(.mobile-menu) .context-menu-item:hover > .submenu {
                display: block;
            }
            .submenu.open-left {
                left: auto;
                right: 100%;
            }
            #contextMenu.mobile-menu .context-menu-item.has-submenu::after {
                content: "◀";
            }
            #contextMenu.mobile-menu .submenu {
                left: auto;
                right: 100%;
            }
            #contextMenu.mobile-menu .context-menu-item:hover > .submenu {
                display: none;
            }
            #contextMenu.mobile-menu .context-menu-item.open > .submenu {
                display: block;
            }

            /* Light Mode for Context Menu */
            body.light-mode #contextMenu,
            body.light-mode .submenu {
                background: #f0f0f0;
                border: 1px solid #ccc;
                border-radius: 6px;
                box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15);
            }
            body.light-mode .context-menu-item {
                color: #000;
            }
            body.light-mode .context-menu-item:hover {
                background: #0078d7;
                color: white;
            }
            body.light-mode .context-menu-divider {
                border-top: 1px solid #ccc;
                margin: 4px 0;
                border-bottom: none;
                height: 1px;
            }

            /* --- Base Modal Styles --- */
            .modal-base {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                background: linear-gradient(to bottom, #4a4a4a, #303030);
                border: 1px solid #444;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
                z-index: 4000;
                padding: 20px;
                border-radius: 8px;
                display: flex;
                flex-direction: column;
            }
            .modal-close-btn {
                position: absolute;
                top: 5px;
                right: 10px;
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #ccc;
            }
            .modal-close-btn:hover {
                color: var(--accent-orange);
            }
            .modal-base h3 {
                margin-top: 0;
                margin-bottom: 15px;
                text-align: center;
                color: var(--accent-orange);
                font-weight: normal;
            }
            /* Light mode for Modals */
            body.light-mode .modal-base {
                background: #fff;
                border: 1px solid #ccc;
                border-radius: 8px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
                color: #000;
            }
            body.light-mode .modal-base h3 {
                color: #333;
            }
            body.light-mode .modal-close-btn {
                color: #555;
            }

            /* --- Help Modal --- */
            #helpModal {
                max-width: 600px;
                max-height: 85vh;
            }
            #helpModal pre {
                background: var(--bg-content);
                padding: 15px;
                border-radius: 4px;
                white-space: pre-wrap;
                font-family: monospace, "Courier New";
                font-size: 13px;
                color: #e0e0e0;
                line-height: 1.6;
                overflow-y: auto;
                border: 1px solid #888;
            }
            body.light-mode #helpModal pre {
                background: #f8f8f8;
                color: #333;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            .help-footer {
                margin-top: 20px;
                padding-top: 15px;
                border-top: 1px solid var(--border-color);
                text-align: center;
            }
            .help-footer a {
                color: var(--accent-orange);
                text-decoration: none;
                font-weight: bold;
            }
            .help-footer a:hover {
                text-decoration: underline;
            }
            body.light-mode .help-footer {
                border-top-color: #ddd;
            }
            body.light-mode .help-footer a {
                color: #0366d6;
            }

            /* --- Expansions Modal --- */
            #expansionsModal {
                max-width: 700px;
            }
            #expansionsList {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 10px;
                margin-bottom: 15px;
                overflow-y: auto;
                max-height: 60vh;
                padding: 10px;
                background: var(--bg-content);
                border: 1px solid #888;
                border-radius: 4px;
            }
            .expansion-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            .expansion-item label {
                font-weight: bold;
                font-family: monospace;
                color: var(--accent-orange);
            }
            .expansion-item input {
                flex-grow: 1;
                padding: 5px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                font-family: monospace;
                background: #333;
                color: #e0e0e0;
            }
            .expansion-item input:focus {
                outline: 1px solid var(--accent-orange);
                border-color: var(--accent-orange);
            }
            .expansions-footer {
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: auto;
                padding-top: 15px;
                border-top: 1px solid var(--border-color);
            }
            .expansions-footer button {
                padding: 6px 12px;
                border: 1px solid var(--border-color);
                background: var(--bg-ui);
                color: var(--text-main);
                cursor: pointer;
                border-radius: 4px;
            }
            .expansions-footer button:hover {
                background: var(--bg-ui-hover);
            }

            /* Light mode for Expansions */
            body.light-mode #expansionsList {
                background: #f8f8f8;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            body.light-mode .expansion-item label {
                color: #000;
            }
            body.light-mode .expansion-item input {
                background: #fff;
                color: #000;
                border: 1px solid #ccc;
                border-radius: 4px;
            }
            body.light-mode .expansions-footer {
                border-top: 1px solid #eee;
            }
            body.light-mode .expansions-footer button {
                background: #e0e0e0;
                border: 1px solid #aaa;
                border-radius: 4px;
                color: #000;
            }
            body.light-mode .expansions-footer button:hover {
                background: #d0d0d0;
            }

            /* --- Rendered Markdown Styles --- */
            .markdown-body h1,
            .markdown-body h2,
            .markdown-body h3,
            .markdown-body h4,
            .markdown-body h5,
            .markdown-body h6 {
                margin-top: 24px;
                margin-bottom: 16px;
                font-weight: 600;
                line-height: 1.25;
                color: var(--accent-orange);
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 0.3em;
            }
            .markdown-body h1 {
                font-size: 2em;
            }
            .markdown-body h2 {
                font-size: 1.5em;
            }
            .markdown-body p {
                margin-bottom: 16px;
            }
            .markdown-body a {
                color: #58a6ff;
                text-decoration: none;
            }
            .markdown-body a:hover {
                text-decoration: underline;
            }
            .markdown-body ul,
            .markdown-body ol {
                margin-bottom: 16px;
                padding-left: 2em;
            }
            .markdown-body blockquote {
                margin: 0 0 16px;
                padding: 0 1em;
                color: #a0a0a0;
                border-left: 0.25em solid var(--border-color);
            }
            .markdown-body code {
                font-family: monospace;
                background-color: var(--bg-ui);
                padding: 0.2em 0.4em;
                margin: 0;
                font-size: 85%;
                border-radius: 6px;
            }
            .markdown-body pre {
                font-family: monospace;
                word-wrap: normal;
                padding: 16px;
                overflow: auto;
                font-size: 85%;
                line-height: 1.45;
                background-color: var(--bg-ui);
                border-radius: 6px;
                margin-bottom: 16px;
            }
            .markdown-body pre code {
                display: inline;
                max-width: auto;
                padding: 0;
                margin: 0;
                overflow: visible;
                line-height: inherit;
                word-wrap: normal;
                background-color: transparent;
                border: 0;
            }
            .markdown-body table {
                display: block;
                width: 100%;
                overflow: auto;
                margin-bottom: 16px;
                border-collapse: collapse;
            }
            .markdown-body tr {
                background-color: var(--bg-content);
                border-top: 1px solid var(--border-color);
            }
            .markdown-body th,
            .markdown-body td {
                padding: 6px 13px;
                border: 1px solid var(--border-color);
            }
            .markdown-body th {
                font-weight: 600;
            }

            body.light-mode .markdown-body h1,
            body.light-mode .markdown-body h2,
            body.light-mode .markdown-body h3,
            body.light-mode .markdown-body h4,
            body.light-mode .markdown-body h5,
            body.light-mode .markdown-body h6 {
                color: #d73a49;
                border-bottom-color: #eaecef;
            }
            body.light-mode .markdown-body a {
                color: #0366d6;
            }
            body.light-mode .markdown-body blockquote {
                color: #6a737d;
                border-left-color: #dfe2e5;
            }
            body.light-mode .markdown-body code {
                background-color: rgba(27, 31, 35, 0.05);
            }
            body.light-mode .markdown-body pre {
                background-color: #f6f8fa;
            }
            body.light-mode .markdown-body tr {
                background-color: #fff;
                border-top-color: #c6cbd1;
            }
            body.light-mode .markdown-body th,
            body.light-mode .markdown-body td {
                border-color: #d0d7de;
            }

            /* --- Utility Classes --- */
            .hidden {
                display: none !important;
            }
            .modal-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 2999;
            }

            /* --- Responsive Design --- */
            @media (max-width: 768px) {
                #editor,
                #previewPane {
                    padding: 15px;
                    font-size: 16px;
                }
                #contextMenu {
                    width: 280px;
                    max-width: calc(100vw - 20px);
                }
                #findReplaceDialog {
                    width: calc(100% - 20px);
                    top: 10px;
                    right: 10px;
                }
                body.split-view-active #mainContent {
                    flex-direction: column;
                }
                body.split-view-active #editor,
                body.split-view-active #previewPane {
                    width: 100%;
                    height: 50vh;
                }
            }
            @media (max-width: 480px) {
                #contextMenu {
                    width: calc(100vw - 20px);
                }
                .modal-base {
                    width: calc(100vw - 20px);
                    max-height: calc(100vh - 40px);
                }
            }
        </style>
    </head>
    <body>
        <div id="mainContent">
            <textarea
                id="editor"
                placeholder="Start typing or right-click / click ☰ for menu."
                autocomplete="off"
                autocorrect="off"
                autocapitalize="off"
                spellcheck="false"
            ></textarea>
            <div id="previewPane" class="hidden"></div>
        </div>

        <div id="gridContainer" class="hidden">
            <div id="gridToolbar">
                <button id="addRowBtn">Add Row</button>
                <button id="addColBtn">Add Column</button>
                <button id="delRowBtn">Delete Row</button>
                <button id="delColBtn">Delete Column</button>
            </div>
            <div id="gridContent"></div>
        </div>

        <div id="findReplaceDialog" class="hidden">
            <input
                type="text"
                id="findInput"
                placeholder="Find (Enter/Shift+Enter)"
            />
            <div class="find-controls">
                <button id="findPrevBtn" title="Find Previous (Shift+Enter)">
                    ↑
                </button>
                <button id="findNextBtn" title="Find Next (Enter)">↓</button>
            </div>
            <input type="text" id="replaceInput" placeholder="Replace" />
            <div class="replace-controls">
                <button id="replaceBtn" title="Replace">Replace</button>
                <button id="replaceAllBtn" title="Replace All">All</button>
            </div>
            <button id="closeFindBtn" title="Close (Esc)">&times;</button>
        </div>

        <div id="helpModal" class="hidden modal-base">
            <button id="closeHelpBtn" class="modal-close-btn">&times;</button>
            <h3>editr Help & Shortcuts</h3>
            <pre id="helpText">
GENERAL
Open Menu          : Right-click / ☰
Show Help          : ?
Fullscreen         : F11
---
Create/Open Note   : editr.cc/#NOTE

FILE MANAGEMENT
New Tab            : Ctrl/Cmd + N
Open File          : Ctrl/Cmd + O
Save File As       : Ctrl/Cmd + S
Close Buffer       : Ctrl/Cmd + W
---
Export as HTML     : Ctrl/Cmd + Alt + H
Export as PDF      : Ctrl/Cmd + Alt + P
---
Export Project     : Ctrl/Cmd + Shift + E
Import Project     : Ctrl/Cmd + Shift + I

NAVIGATION
Next Buffer        : Ctrl/Cmd + →
Previous Buffer    : Ctrl/Cmd + ←
Switch to Buffer # : Ctrl/Cmd + (1-9)
Open Link from Line: Ctrl/Cmd + L

EDITING
Find / Replace     : Ctrl/Cmd + F
Lock/Unlock Note   : Ctrl/Cmd + =
Text Expansions    : Ctrl/Cmd + E

MARKDOWN FORMATTING
Bold               : Ctrl/Cmd + B
Italic             : Ctrl/Cmd + I
Strikethrough      : Ctrl/Cmd + Shift + X
Link               : Ctrl/Cmd + K
Bulleted List      : Ctrl/Cmd + Shift + L
Numbered List      : Ctrl/Cmd + Shift + O
Blockquote         : Ctrl/Cmd + '
Inline Code        : Ctrl/Cmd + `
Code Block         : Ctrl/Cmd + Shift + K
Heading 1-6        : Ctrl/Cmd + Alt + (1-6)

VIEW OPTIONS
Toggle Light Mode  : Ctrl/Cmd + D
Toggle Preview     : Ctrl/Cmd + M
Toggle Grid View   : Ctrl/Cmd + Shift + G
Toggle Word Wrap   : Alt + Z
Show/Hide File Name: Ctrl/Cmd + Alt + F
Show/Hide Stats    : Ctrl/Cmd + Alt + S

TOOLS
Calculator         : Ctrl/Cmd + Shift + C
Calendar           : Ctrl/Cmd + Alt + C
Email Buffer       : Ctrl/Cmd + Shift + M
---
Text Expansions: Type shortcut (e.g., .d) and press Space or Enter.
            </pre>
            <p class="help-footer">
                <a
                    href="https://sourceforge.net/projects/edit/"
                    target="_blank"
                    rel="noopener noreferrer"
                    >Install on Windows & Mac</a
                >
            </p>
        </div>

        <div id="expansionsModal" class="hidden modal-base">
            <button id="closeExpansionsBtn" class="modal-close-btn">
                &times;
            </button>
            <h3>Text Expansions</h3>
            <div id="expansionsList"></div>
            <div class="expansions-footer">
                <button
                    id="importExpansionsBtn"
                    title="Import from a .txt file"
                >
                    Import
                </button>
                <button id="exportExpansionsBtn" title="Export to a .txt file">
                    Export
                </button>
                <button id="saveExpansionsBtn" title="Save changes and close">
                    Save & Close
                </button>
            </div>
        </div>

        <div id="contextMenu">
            <div id="ctxBufferList"></div>
            <hr class="context-menu-divider" id="ctxBufferDivider" />

            <div class="context-menu-item has-submenu">
                <span>File</span>
                <div class="submenu">
                    <div class="context-menu-item" id="ctxNewTab">
                        <span>New Tab</span>
                        <span class="shortcut">Ctrl + N</span>
                    </div>
                    <div class="context-menu-item" id="ctxOpenFile">
                        <span>Open File</span>
                        <span class="shortcut">Ctrl + O</span>
                    </div>
                    <div class="context-menu-item" id="ctxSaveFile">
                        <span>Save As</span>
                        <span class="shortcut">Ctrl + S</span>
                    </div>
                    <hr class="context-menu-divider" />
                    <div class="context-menu-item" id="ctxExportHTML">
                        <span>Export HTML</span>
                        <span class="shortcut">Ctrl + Alt + H</span>
                    </div>
                    <div class="context-menu-item" id="ctxExportPDF">
                        <span>Export PDF</span>
                        <span class="shortcut">Ctrl + Alt + P</span>
                    </div>
                    <hr class="context-menu-divider" />
                    <div class="context-menu-item" id="ctxFindReplace">
                        <span>Find / Replace</span>
                        <span class="shortcut">Ctrl + F</span>
                    </div>
                    <hr class="context-menu-divider" />
                    <div class="context-menu-item" id="ctxExportProject">
                        <span>Export Project</span>
                        <span class="shortcut">Ctrl + Shift + E</span>
                    </div>
                    <div class="context-menu-item" id="ctxImportProject">
                        <span>Import Project</span>
                        <span class="shortcut">Ctrl + Shift + I</span>
                    </div>
                </div>
            </div>

            <div class="context-menu-item has-submenu">
                <span id="ctxBufferMenuLabel">Buffer</span>
                <div class="submenu">
                    <div class="context-menu-item" id="ctxNextBuffer">
                        <span>Next Buffer</span>
                        <span class="shortcut">Ctrl + →</span>
                    </div>
                    <div class="context-menu-item" id="ctxPrevBuffer">
                        <span>Previous Buffer</span>
                        <span class="shortcut">Ctrl + ←</span>
                    </div>
                    <div class="context-menu-item" id="ctxCloseBuffer">
                        <span>Close Buffer</span>
                        <span class="shortcut">Ctrl + W</span>
                    </div>
                    <hr class="context-menu-divider" />
                    <div class="context-menu-item" id="ctxEmailBuffer">
                        <span>Email Buffer</span>
                        <span class="shortcut">Ctrl + Shift + M</span>
                    </div>
                </div>
            </div>

            <div class="context-menu-item has-submenu">
                <span>Tools</span>
                <div class="submenu">
                    <div class="context-menu-item" id="ctxOpenLink">
                        <span>Open Link</span>
                        <span class="shortcut">Ctrl + L</span>
                    </div>
                    <div class="context-menu-item" id="ctxToggleLock">
                        <span>Lock/Unlock Note</span>
                        <span class="shortcut">Ctrl + =</span>
                    </div>
                    <div class="context-menu-item" id="ctxManageExpansions">
                        <span>Text Expansions</span>
                        <span class="shortcut">Ctrl + E</span>
                    </div>
                    <hr class="context-menu-divider" />
                    <div class="context-menu-item" id="ctxCalculator">
                        <span>Calculator</span>
                        <span class="shortcut">Ctrl + Shift + C</span>
                    </div>
                    <div class="context-menu-item" id="ctxCalendar">
                        <span>Calendar</span>
                        <span class="shortcut">Ctrl + Alt + C</span>
                    </div>
                </div>
            </div>

            <div class="context-menu-item has-submenu">
                <span>View</span>
                <div class="submenu">
                    <div class="context-menu-item" id="ctxTogglePreview">
                        <span>Markdown Preview</span>
                        <span class="shortcut">Ctrl + M</span>
                    </div>
                    <div class="context-menu-item" id="ctxToggleGridView">
                        <span>Grid View</span>
                        <span class="shortcut">Ctrl + Shift + G</span>
                    </div>
                    <div class="context-menu-item" id="ctxToggleDark">
                        <span>Dark/Light Mode</span>
                        <span class="shortcut">Ctrl + D</span>
                    </div>
                    <div class="context-menu-item" id="ctxToggleWrap">
                        <span>Word Wrap</span>
                        <span class="shortcut">Alt + Z</span>
                    </div>
                    <div class="context-menu-item" id="ctxToggleFileName">
                        <span>File Name</span>
                        <span class="shortcut">Ctrl + Alt + F</span>
                    </div>
                    <div class="context-menu-item" id="ctxToggleStats">
                        <span>Stats</span>
                        <span class="shortcut">Ctrl + Alt + S</span>
                    </div>
                    <div class="context-menu-item" id="ctxToggleFullscreen">
                        <span>Fullscreen</span>
                        <span class="shortcut">F11</span>
                    </div>
                </div>
            </div>

            <hr class="context-menu-divider" />
            <div class="context-menu-item" id="ctxShowHelp">
                <span>Help</span>
                <span class="shortcut">?</span>
            </div>
        </div>

        <div id="mobileControls">
            <div id="fileNameDisplay"></div>
            <div id="statsDisplay" class="hidden">
                <span id="lineStat">↓1</span>
                <span id="charStat">→1</span>
                <span id="wordStat">=0</span>
            </div>
            <button class="mobile-btn" id="hamburgerBtn" title="Menu">
                ☰
            </button>
        </div>

        <input
            type="file"
            id="fileInput"
            accept=".txt,.md,.js,.html,.css,.csv,.tsv"
        />
        <input
            type="file"
            id="importExpansionsInput"
            accept=".txt"
            style="display: none"
        />

        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

        <script>
            document.addEventListener("DOMContentLoaded", function () {
                // Get DOM elements
                const editor = document.getElementById("editor");
                const previewPane = document.getElementById("previewPane");
                const mainContent = document.getElementById("mainContent");
                const fileInput = document.getElementById("fileInput");
                const currentBuffer = document.getElementById("currentBuffer");
                const contextMenu = document.getElementById("contextMenu");
                const helpModal = document.getElementById("helpModal");
                const closeHelpBtn = document.getElementById("closeHelpBtn");
                const hamburgerBtn = document.getElementById("hamburgerBtn");

                // Grid View DOM elements
                const gridContainer = document.getElementById("gridContainer");
                const gridContent = document.getElementById("gridContent");
                const addRowBtn = document.getElementById("addRowBtn");
                const addColBtn = document.getElementById("addColBtn");
                const delRowBtn = document.getElementById("delRowBtn");
                const delColBtn = document.getElementById("delColBtn");

                // Expansions DOM elements
                const expansionsModal =
                    document.getElementById("expansionsModal");
                const closeExpansionsBtn =
                    document.getElementById("closeExpansionsBtn");
                const expansionsList =
                    document.getElementById("expansionsList");
                const saveExpansionsBtn =
                    document.getElementById("saveExpansionsBtn");
                const importExpansionsBtn = document.getElementById(
                    "importExpansionsBtn",
                );
                const exportExpansionsBtn = document.getElementById(
                    "exportExpansionsBtn",
                );
                const importExpansionsInput = document.getElementById(
                    "importExpansionsInput",
                );

                // Find/Replace DOM elements
                const findReplaceDialog =
                    document.getElementById("findReplaceDialog");
                const findInput = document.getElementById("findInput");
                const replaceInput = document.getElementById("replaceInput");
                const findNextBtn = document.getElementById("findNextBtn");
                const findPrevBtn = document.getElementById("findPrevBtn");
                const replaceBtn = document.getElementById("replaceBtn");
                const replaceAllBtn = document.getElementById("replaceAllBtn");
                const closeFindBtn = document.getElementById("closeFindBtn");

                // Stats Display elements
                const statsDisplay = document.getElementById("statsDisplay");
                const lineStat = document.getElementById("lineStat");
                const charStat = document.getElementById("charStat");
                const wordStat = document.getElementById("wordStat");
                const fileNameDisplay =
                    document.getElementById("fileNameDisplay");

                // Crypto constants
                const ENCRYPTION_ALGORITHM = "AES-GCM";
                const KEY_DERIVATION_ALGORITHM = "PBKDF2";
                const HASH_ALGORITHM = "SHA-256";
                const KEY_DERIVATION_ITERATIONS = 100000;
                // Special buffer names
                const CALC_BUFFER_NAME = "[Calculator]";
                const CALENDAR_BUFFER_NAME = "[Calendar]";

                let tabId;
                let buffers = [];
                let activeBufferIndex = 0;
                let expansions = {};
                let calendarInterval = null;
                let selectedGridCell = null;

                // --- App State & Settings ---
                let lastSearch = { term: "" };
                let lastMatch = null; // To store the last find result's position {start, end}
                const bracketPairs = { "(": ")", "[": "]", "{": "}" };

                // --- PWA File Handling ---
                function handleLaunchedFiles() {
                    if ("launchQueue" in window) {
                        launchQueue.setConsumer(async (launchParams) => {
                            if (
                                !launchParams.files ||
                                launchParams.files.length === 0
                            ) {
                                return;
                            }
                            for (const fileHandle of launchParams.files) {
                                try {
                                    const file = await fileHandle.getFile();
                                    const content = await file.text();
                                    createNewBuffer(
                                        file.name,
                                        content,
                                        fileHandle,
                                    );
                                } catch (error) {
                                    console.error(
                                        "Error handling launched file:",
                                        error,
                                    );
                                }
                            }
                        });
                    }
                }

                function initializeTabAndUrl() {
                    const hash = window.location.hash.slice(1); // Remove the #

                    if (hash) {
                        // Parse the hash to extract just the tabId (everything before the first dash)
                        const hashParts = hash.split("-");
                        tabId = hashParts[0];
                    } else {
                        tabId = Math.random().toString(36).substr(2, 6);
                        window.location.hash = tabId;
                    }
                }

                function getFileNameForUrl(fileName) {
                    // Remove file extension
                    const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "");
                    // Convert to lowercase and replace non-alphanumeric characters with nothing
                    // This ensures we get a clean URL-safe string
                    return nameWithoutExt
                        .toLowerCase()
                        .replace(/[^a-z0-9]/g, "");
                }

                function updateUrlForCurrentBuffer() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer || buffer.isSpecial) return;

                    let newHash;
                    if (buffer.name === "editr.txt") {
                        // For default buffer, just use the tab ID
                        newHash = tabId;
                    } else {
                        // For other files, use tabId + filename (but ensure we don't duplicate)
                        const urlName = getFileNameForUrl(buffer.name);
                        newHash = `${tabId}-${urlName}`;
                    }

                    // Only update if the hash is actually different
                    const currentHash = window.location.hash.slice(1);
                    if (currentHash !== newHash) {
                        // Use replaceState to avoid adding to browser history for every buffer switch
                        window.history.replaceState(null, null, `#${newHash}`);
                    }
                }

                function handleHashChange() {
                    const newHash = window.location.hash.slice(1);
                    if (!newHash) return;

                    // Parse the hash to extract tabId and potential filename
                    const hashParts = newHash.split("-");
                    const newTabId = hashParts[0];

                    // If this is a different tab entirely, we could handle that here
                    if (newTabId && newTabId !== tabId) {
                        tabId = newTabId;
                        // Optionally reload buffers for the new tab
                    }
                }

                class FileBuffer {
                    constructor(
                        name = "editr.txt",
                        content = "",
                        fileHandle = null,
                        isLocked = false,
                        encryptedContent = null,
                        salt = null,
                        iv = null,
                    ) {
                        this.name = name;
                        this.content = content;
                        this.originalContent = content;
                        this.fileHandle = fileHandle;
                        this.id = Math.random().toString(36).substr(2, 9);
                        this.isLocked = isLocked;
                        this.encryptedContent = encryptedContent;
                        this.salt = salt;
                        this.iv = iv;
                        this.isSpecial = false; // For calculator/calendar buffers
                        this.isGridView = false; // For CSV/TSV grid view
                    }
                    get isModified() {
                        if (this.isLocked || this.isSpecial) return false;
                        return this.content !== this.originalContent;
                    }
                    markSaved() {
                        this.originalContent = this.content;
                    }
                }

                async function deriveKey(password, salt) {
                    const enc = new TextEncoder();
                    const keyMaterial = await window.crypto.subtle.importKey(
                        "raw",
                        enc.encode(password),
                        { name: KEY_DERIVATION_ALGORITHM },
                        false,
                        ["deriveKey"],
                    );
                    return window.crypto.subtle.deriveKey(
                        {
                            name: KEY_DERIVATION_ALGORITHM,
                            salt: salt,
                            iterations: KEY_DERIVATION_ITERATIONS,
                            hash: HASH_ALGORITHM,
                        },
                        keyMaterial,
                        { name: ENCRYPTION_ALGORITHM, length: 256 },
                        true,
                        ["encrypt", "decrypt"],
                    );
                }

                async function encryptText(text, password) {
                    const salt = window.crypto.getRandomValues(
                        new Uint8Array(16),
                    );
                    const iv = window.crypto.getRandomValues(
                        new Uint8Array(12),
                    );
                    const key = await deriveKey(password, salt);
                    const enc = new TextEncoder();
                    const encodedText = enc.encode(text);
                    const encryptedContent = await window.crypto.subtle.encrypt(
                        { name: ENCRYPTION_ALGORITHM, iv: iv },
                        key,
                        encodedText,
                    );
                    return {
                        encryptedContent: btoa(
                            String.fromCharCode.apply(
                                null,
                                new Uint8Array(encryptedContent),
                            ),
                        ),
                        salt: btoa(String.fromCharCode.apply(null, salt)),
                        iv: btoa(String.fromCharCode.apply(null, iv)),
                    };
                }

                async function decryptText(
                    encryptedContentB64,
                    password,
                    saltB64,
                    ivB64,
                ) {
                    try {
                        const salt = new Uint8Array(
                            atob(saltB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const iv = new Uint8Array(
                            atob(ivB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const encryptedContent = new Uint8Array(
                            atob(encryptedContentB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const key = await deriveKey(password, salt);
                        const decryptedContent =
                            await window.crypto.subtle.decrypt(
                                { name: ENCRYPTION_ALGORITHM, iv: iv },
                                key,
                                encryptedContent,
                            );
                        const dec = new TextDecoder();
                        return dec.decode(decryptedContent);
                    } catch (e) {
                        console.error("Decryption failed:", e);
                        return null;
                    }
                }

                function saveBuffersToLocalStorage() {
                    const buffersToSave = buffers
                        .filter((buffer) => !buffer.isSpecial) // Don't save special buffers
                        .map((buffer) => ({
                            name: buffer.name,
                            content: buffer.isLocked ? "" : buffer.content,
                            originalContent: buffer.originalContent,
                            isLocked: buffer.isLocked,
                            encryptedContent: buffer.encryptedContent,
                            salt: buffer.salt,
                            iv: buffer.iv,
                            isGridView: buffer.isGridView,
                        }));
                    localStorage.setItem(
                        `editr_buffers_${tabId}`,
                        JSON.stringify(buffersToSave),
                    );
                    localStorage.setItem(
                        `editr_active_buffer_index_${tabId}`,
                        activeBufferIndex,
                    );
                }

                function saveExpansions() {
                    localStorage.setItem(
                        "editr_expansions",
                        JSON.stringify(expansions),
                    );
                }

                function loadExpansions() {
                    const savedExpansions =
                        localStorage.getItem("editr_expansions");
                    if (savedExpansions) {
                        expansions = JSON.parse(savedExpansions);
                    } else {
                        // Initialize with empty strings for all customizable shortcuts
                        expansions = {};
                        const shortcuts = "abcdefghijklmnopqrstuvwxyz".split(
                            "",
                        ); // Now includes q
                        shortcuts.forEach((char) => {
                            expansions["." + char] = "";
                        });
                        // Set default value for .d expansion
                        expansions[".d"] = "YYYYMMDD";
                    }
                }

                function initializeBuffers() {
                    const savedBuffersData = localStorage.getItem(
                        `editr_buffers_${tabId}`,
                    );
                    if (savedBuffersData) {
                        const savedBuffers = JSON.parse(savedBuffersData);
                        buffers = savedBuffers.map((b) => {
                            const buffer = new FileBuffer(
                                b.name,
                                b.content,
                                null,
                                b.isLocked,
                                b.encryptedContent,
                                b.salt,
                                b.iv,
                            );
                            buffer.isGridView = b.isGridView || false;
                            return buffer;
                        });
                        activeBufferIndex =
                            parseInt(
                                localStorage.getItem(
                                    `editr_active_buffer_index_${tabId}`,
                                ),
                                10,
                            ) || 0;
                        if (activeBufferIndex >= buffers.length)
                            activeBufferIndex = 0;
                    } else {
                        // Migration from older version if needed
                        const oldContentKey = `editr_${tabId}_editorContent`;
                        const savedContent =
                            localStorage.getItem(oldContentKey) || "";
                        buffers = [new FileBuffer("editr.txt", savedContent)];
                        activeBufferIndex = 0;
                        if (localStorage.getItem(oldContentKey)) {
                            saveBuffersToLocalStorage();
                            localStorage.removeItem(oldContentKey);
                        }
                    }
                    if (buffers.length === 0) {
                        buffers = [new FileBuffer("editr.txt", "")];
                        activeBufferIndex = 0;
                    }
                    updateBufferBar();
                    loadActiveBuffer();
                }

                function createNewBuffer(
                    name = "editr.txt",
                    content = "",
                    fileHandle = null,
                ) {
                    const buffer = new FileBuffer(name, content, fileHandle);
                    const fileExt = name.split(".").pop().toLowerCase();
                    if (["csv", "tsv"].includes(fileExt)) {
                        buffer.isGridView = true;
                    }
                    buffers.push(buffer);
                    activeBufferIndex = buffers.length - 1;
                    updateBufferBar();
                    loadActiveBuffer();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                    return buffer;
                }

                function switchToBuffer(index) {
                    if (index < 0 || index >= buffers.length) return;

                    // Save current buffer state before switching
                    const currentBuf = buffers[activeBufferIndex];
                    if (currentBuf) {
                        if (currentBuf.isGridView) {
                            gridToContent(currentBuf);
                        } else if (
                            !currentBuf.isLocked &&
                            !currentBuf.isSpecial
                        ) {
                            currentBuf.content = editor.value;
                        }
                    }

                    // Clear calendar interval when switching away from a calendar buffer
                    if (calendarInterval) {
                        clearInterval(calendarInterval);
                        calendarInterval = null;
                    }

                    activeBufferIndex = index;
                    loadActiveBuffer();
                    updateBufferBar();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                }

                function closeBuffer(index) {
                    if (buffers.length === 1) return;
                    const buffer = buffers[index];
                    if (buffer.isModified && !buffer.isLocked) {
                        if (
                            !confirm(
                                `"${buffer.name}" has unsaved changes. Close anyway?`,
                            )
                        ) {
                            return;
                        }
                    }
                    buffers.splice(index, 1);
                    if (activeBufferIndex >= index && activeBufferIndex > 0) {
                        activeBufferIndex--;
                    } else if (activeBufferIndex >= buffers.length) {
                        activeBufferIndex = buffers.length - 1;
                    }
                    updateBufferBar();
                    loadActiveBuffer();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                }

                function loadActiveBuffer() {
                    if (calendarInterval) clearInterval(calendarInterval); // Clear any existing interval
                    selectedGridCell = null;

                    const buffer = buffers[activeBufferIndex];
                    if (buffer) {
                        if (buffer.isGridView) {
                            mainContent.classList.add("hidden");
                            gridContainer.classList.remove("hidden");
                            renderGridView(buffer);
                        } else {
                            mainContent.classList.remove("hidden");
                            gridContainer.classList.add("hidden");
                            if (buffer.name === CALENDAR_BUFFER_NAME) {
                                // Handle calendar buffer
                                editor.value = generateCalendarView(
                                    buffer.calendarDate,
                                );
                                editor.readOnly = true;
                                editor.placeholder =
                                    "Calendar View. 'n' for next, 'p' for previous.";
                                calendarInterval = setInterval(() => {
                                    if (
                                        activeBufferIndex >= buffers.length ||
                                        buffers[activeBufferIndex].name !==
                                            CALENDAR_BUFFER_NAME
                                    ) {
                                        clearInterval(calendarInterval);
                                        calendarInterval = null;
                                        return;
                                    }
                                    const { scrollTop, scrollLeft } = editor;
                                    editor.value = generateCalendarView(
                                        buffers[activeBufferIndex].calendarDate,
                                    );
                                    editor.scrollTop = scrollTop;
                                    editor.scrollLeft = scrollLeft;
                                }, 1000);
                            } else if (buffer.isLocked) {
                                editor.value = "";
                                editor.placeholder =
                                    "🔒 This note is locked. Press Ctrl/Cmd + = to unlock.";
                                editor.readOnly = true;
                            } else {
                                editor.value = buffer.content;
                                editor.placeholder =
                                    "Start typing or right-click / click ☰ for menu.";
                                // Default to not read-only for regular and calculator buffers
                                editor.readOnly = false;
                            }
                        }
                        updateStatsDisplay();
                        updateBufferBar();
                        updatePreview();
                        if (!buffer.isGridView) editor.focus();
                    }
                }

                function updateBufferBar() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;

                    if (fileNameDisplay) {
                        fileNameDisplay.textContent = buffer.name;
                        fileNameDisplay.title = buffer.name; // Add a tooltip for long names
                    }

                    if (currentBuffer) {
                        const modifiedText =
                            buffer.isModified && !buffer.isLocked
                                ? " (modified)"
                                : "";
                        const lockedText = buffer.isLocked ? " 🔒" : "";
                        const viewMode = buffer.isGridView ? " [Grid]" : "";
                        currentBuffer.textContent = `Buffer: ${
                            activeBufferIndex + 1
                        }/${buffers.length} - ${buffer.name}${lockedText}${modifiedText}${viewMode}`;
                    }
                }

                // --- Grid View Logic ---
                function toggleGridView() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer || buffer.isSpecial || buffer.isLocked) return;

                    buffer.isGridView = !buffer.isGridView;

                    if (buffer.isGridView) {
                        // Switching to Grid View
                        buffer.content = editor.value; // Save latest from editor
                        mainContent.classList.add("hidden");
                        gridContainer.classList.remove("hidden");
                        renderGridView(buffer);
                    } else {
                        // Switching to Text View
                        gridToContent(buffer);
                        mainContent.classList.remove("hidden");
                        gridContainer.classList.add("hidden");
                        editor.value = buffer.content;
                        editor.focus();
                    }
                    updateBufferBar();
                    saveBuffersToLocalStorage();
                }

                function parseCsvTsv(text, fileName) {
                    const delimiter = fileName.endsWith(".tsv") ? "\t" : ",";
                    const rows = text.trim().split("\n");
                    return rows.map((row) => row.split(delimiter));
                }

                function renderGridView(buffer) {
                    const data = parseCsvTsv(buffer.content, buffer.name);
                    if (!data || data.length === 0) {
                        gridContent.innerHTML = "<table></table>";
                        return;
                    }

                    let tableHtml = "<table><thead><tr>";
                    const numCols = data.reduce(
                        (max, row) => Math.max(max, row.length),
                        0,
                    );

                    for (let i = 0; i < numCols; i++) {
                        tableHtml += `<th>${String.fromCharCode(65 + i)}</th>`;
                    }
                    tableHtml += "</tr></thead><tbody>";

                    data.forEach((row, rowIndex) => {
                        tableHtml += "<tr>";
                        for (let colIndex = 0; colIndex < numCols; colIndex++) {
                            const cellData = row[colIndex] || "";
                            tableHtml += `<td data-row="${rowIndex}" data-col="${colIndex}" contenteditable="true">${cellData}</td>`;
                        }
                        tableHtml += "</tr>";
                    });

                    tableHtml += "</tbody></table>";
                    gridContent.innerHTML = tableHtml;
                }

                function gridToContent(buffer) {
                    const table = gridContent.querySelector("table");
                    if (!table) return;

                    const delimiter = buffer.name.endsWith(".tsv") ? "\t" : ",";
                    let content = "";
                    const rows = table.querySelectorAll("tbody tr");
                    rows.forEach((tr) => {
                        const cells = Array.from(tr.querySelectorAll("td"));
                        content +=
                            cells.map((td) => td.textContent).join(delimiter) +
                            "\n";
                    });
                    buffer.content = content;
                    buffer.markSaved(); // Consider changes in grid as saved to buffer content
                }

                function addGridRow() {
                    const table = gridContent.querySelector("table tbody");
                    if (!table) return;
                    const numCols = table.rows[0]
                        ? table.rows[0].cells.length
                        : 1;
                    const newRow = table.insertRow();
                    for (let i = 0; i < numCols; i++) {
                        const newCell = newRow.insertCell();
                        newCell.setAttribute("contenteditable", "true");
                        newCell.dataset.row = table.rows.length - 1;
                        newCell.dataset.col = i;
                    }
                }

                function addGridColumn() {
                    const table = gridContent.querySelector("table");
                    if (!table) return;
                    const header = table.querySelector("thead tr");
                    if (header) {
                        const newTh = document.createElement("th");
                        newTh.textContent = String.fromCharCode(
                            65 + header.cells.length,
                        );
                        header.appendChild(newTh);
                    }
                    const rows = table.querySelectorAll("tbody tr");
                    rows.forEach((row, rowIndex) => {
                        const newCell = row.insertCell();
                        newCell.setAttribute("contenteditable", "true");
                        newCell.dataset.row = rowIndex;
                        newCell.dataset.col = row.cells.length - 1;
                    });
                }

                function deleteGridRow() {
                    if (!selectedGridCell) return;
                    const rowIndex = parseInt(selectedGridCell.dataset.row, 10);
                    const table = gridContent.querySelector("table tbody");
                    if (table && table.rows.length > rowIndex) {
                        table.deleteRow(rowIndex);
                        selectedGridCell = null;
                        // Re-index rows
                        Array.from(table.rows).forEach((row, rIdx) => {
                            Array.from(row.cells).forEach(
                                (cell) => (cell.dataset.row = rIdx),
                            );
                        });
                    }
                }

                function deleteGridColumn() {
                    if (!selectedGridCell) return;
                    const colIndex = parseInt(selectedGridCell.dataset.col, 10);
                    const table = gridContent.querySelector("table");
                    if (!table) return;

                    const header = table.querySelector("thead tr");
                    if (header && header.cells.length > colIndex) {
                        header.deleteCell(colIndex);
                    }

                    const rows = table.querySelectorAll("tbody tr");
                    rows.forEach((row) => {
                        if (row.cells.length > colIndex) {
                            row.deleteCell(colIndex);
                        }
                    });
                    selectedGridCell = null;
                    // Re-index columns
                    Array.from(table.rows).forEach((row) => {
                        Array.from(row.cells).forEach(
                            (cell, cIdx) => (cell.dataset.col = cIdx),
                        );
                    });
                    if (header) {
                        Array.from(header.cells).forEach(
                            (th, cIdx) =>
                                (th.textContent = String.fromCharCode(
                                    65 + cIdx,
                                )),
                        );
                    }
                }

                // --- Load App Settings ---
                function loadSettings() {
                    const isLightMode =
                        localStorage.getItem("lightMode") === "true";
                    if (isLightMode) document.body.classList.add("light-mode");

                    const isWordWrapOff =
                        localStorage.getItem("wordWrap") === "false";
                    if (isWordWrapOff) {
                        editor.classList.add("no-wrap");
                    }

                    const showStats =
                        localStorage.getItem("showStats") === "true";
                    if (showStats) {
                        statsDisplay.classList.remove("hidden");
                        updateStatsDisplay();
                    }

                    if (localStorage.getItem("showFileName") === "false") {
                        fileNameDisplay.classList.add("hidden");
                    }

                    if (localStorage.getItem("previewActive") === "true") {
                        togglePreview();
                    }
                }

                function toggleLightMode() {
                    document.body.classList.toggle("light-mode");
                    localStorage.setItem(
                        "lightMode",
                        document.body.classList.contains("light-mode"),
                    );
                }

                function toggleWordWrap() {
                    const isNoWrap = editor.classList.toggle("no-wrap");
                    localStorage.setItem("wordWrap", !isNoWrap);
                    editor.focus();
                }

                function toggleStats() {
                    const isCurrentlyHidden =
                        statsDisplay.classList.contains("hidden");
                    if (isCurrentlyHidden) {
                        statsDisplay.classList.remove("hidden");
                        localStorage.setItem("showStats", "true");
                        updateStatsDisplay();
                    } else {
                        statsDisplay.classList.add("hidden");
                        localStorage.setItem("showStats", "false");
                    }
                }

                function toggleFileNameDisplay() {
                    const isCurrentlyHidden =
                        fileNameDisplay.classList.contains("hidden");
                    if (isCurrentlyHidden) {
                        fileNameDisplay.classList.remove("hidden");
                        localStorage.setItem("showFileName", "true");
                    } else {
                        fileNameDisplay.classList.add("hidden");
                        localStorage.setItem("showFileName", "false");
                    }
                }

                function updateStatsDisplay() {
                    if (
                        !statsDisplay ||
                        statsDisplay.classList.contains("hidden")
                    )
                        return;

                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;

                    let text, lineNumber, charPos, wordCountVal;

                    if (buffer.isGridView) {
                        const table = gridContent.querySelector("table");
                        text = table ? table.innerText : "";
                        lineNumber = "-";
                        charPos = "-";
                        wordCountVal =
                            text.trim() === ""
                                ? 0
                                : text.trim().split(/\s+/).length;
                    } else {
                        text = editor.value;
                        const cursorPos = editor.selectionStart;
                        const textBeforeCursor = text.substring(0, cursorPos);
                        lineNumber =
                            (textBeforeCursor.match(/\n/g) || []).length + 1;
                        const lastNewlineIndex =
                            textBeforeCursor.lastIndexOf("\n");
                        charPos = cursorPos - (lastNewlineIndex + 1) + 1;
                        wordCountVal =
                            text.trim() === ""
                                ? 0
                                : text.trim().split(/\s+/).length;
                    }

                    lineStat.textContent = `↓${lineNumber}`;
                    charStat.textContent = `→${charPos}`;
                    wordStat.textContent = `=${wordCountVal}`;
                }

                async function saveFile() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;
                    if (buffer.isSpecial) {
                        showSaveIndicator(
                            "Cannot save this type of buffer.",
                            true,
                        );
                        return;
                    }
                    if (buffer.isLocked) {
                        showSaveIndicator("Cannot save a locked note!");
                        return;
                    }

                    if (buffer.isGridView) {
                        gridToContent(buffer);
                    } else {
                        buffer.content = editor.value;
                    }
                    const content = buffer.content;

                    if ("showSaveFilePicker" in window && buffer.fileHandle) {
                        try {
                            const writable =
                                await buffer.fileHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            buffer.markSaved();
                            updateBufferBar();
                            showSaveIndicator("Saved!");
                            return;
                        } catch (err) {
                            console.log(
                                "Direct save failed, falling back:",
                                err,
                            );
                        }
                    }

                    if ("showSaveFilePicker" in window) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: buffer.name,
                                types: [
                                    {
                                        description: "Text files",
                                        accept: {
                                            "text/plain": [
                                                ".txt",
                                                ".md",
                                                ".js",
                                                ".html",
                                                ".css",
                                                ".csv",
                                                ".tsv",
                                            ],
                                        },
                                    },
                                ],
                            });
                            const writable = await handle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            buffer.fileHandle = handle;
                            buffer.name = handle.name;
                            buffer.markSaved();
                            updateBufferBar();
                            updateUrlForCurrentBuffer();
                            showSaveIndicator("Saved!");
                            return;
                        } catch (err) {
                            if (err.name !== "AbortError")
                                console.log("Save picker failed:", err);
                            return;
                        }
                    }

                    const blob = new Blob([content], { type: "text/plain" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = buffer.name;
                    a.click();
                    URL.revokeObjectURL(url);
                    buffer.markSaved();
                    updateBufferBar();
                    showSaveIndicator("Downloaded!");
                }

                function showSaveIndicator(message, isError = false) {
                    let indicator = document.getElementById("saveIndicator");
                    if (!indicator) {
                        indicator = document.createElement("div");
                        indicator.id = "saveIndicator";
                        indicator.style.cssText = `position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 16px; border-radius: 4px; font-size: 14px; z-index: 5000; opacity: 0; transition: opacity 0.3s; pointer-events: none;`;
                        document.body.appendChild(indicator);
                    }
                    indicator.textContent = message;
                    indicator.style.background = isError
                        ? "rgba(180, 0, 0, 0.9)"
                        : "rgba(0, 0, 0, 0.8)";
                    indicator.style.opacity = "1";
                    setTimeout(() => {
                        indicator.style.opacity = "0";
                    }, 2000);
                }

                async function openFile() {
                    if ("showOpenFilePicker" in window) {
                        try {
                            const [handle] = await window.showOpenFilePicker({
                                multiple: false,
                            });
                            const file = await handle.getFile();
                            const content = await file.text();
                            createNewBuffer(file.name, content, handle);
                        } catch (err) {
                            if (err.name !== "AbortError")
                                console.log("File picker failed:", err);
                        }
                    } else {
                        fileInput.click();
                    }
                }

                async function toggleLock() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer || buffer.isSpecial) return;
                    if (buffer.isLocked) {
                        const password = prompt("Enter password to unlock:");
                        if (!password) return;
                        const decryptedContent = await decryptText(
                            buffer.encryptedContent,
                            password,
                            buffer.salt,
                            buffer.iv,
                        );
                        if (decryptedContent !== null) {
                            buffer.content = decryptedContent;
                            buffer.isLocked = false;
                            buffer.encryptedContent = null;
                            buffer.salt = null;
                            buffer.iv = null;
                            showSaveIndicator("Note unlocked!");
                        } else {
                            alert("Decryption failed. Incorrect password.");
                            return;
                        }
                    } else {
                        const password = prompt("Enter password to lock note:");
                        if (!password) {
                            alert("Password cannot be empty.");
                            return;
                        }
                        const passwordConfirm = prompt("Confirm password:");
                        if (password !== passwordConfirm) {
                            alert("Passwords do not match.");
                            return;
                        }
                        const { encryptedContent, salt, iv } =
                            await encryptText(editor.value, password);
                        buffer.encryptedContent = encryptedContent;
                        buffer.salt = salt;
                        buffer.iv = iv;
                        buffer.isLocked = true;
                        buffer.content = "";
                        showSaveIndicator("Note locked!");
                    }
                    saveBuffersToLocalStorage();
                    loadActiveBuffer();
                }

                async function exportProject() {
                    const projectData = {
                        version: "1.0",
                        tabId: tabId,
                        activeBufferIndex: activeBufferIndex,
                        buffers: buffers
                            .filter((b) => !b.isSpecial)
                            .map((buffer) => ({
                                name: buffer.name,
                                content: buffer.isLocked ? "" : buffer.content,
                                originalContent: buffer.originalContent,
                                isLocked: buffer.isLocked,
                                encryptedContent: buffer.encryptedContent,
                                salt: buffer.salt,
                                iv: buffer.iv,
                            })),
                        expansions: expansions,
                        exportDate: new Date().toISOString(),
                    };

                    const jsonContent = JSON.stringify(projectData, null, 2);
                    const blob = new Blob([jsonContent], {
                        type: "application/json",
                    });

                    if ("showSaveFilePicker" in window) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: `editr-project-${tabId}.json`,
                                types: [
                                    {
                                        description: "Editr Project files",
                                        accept: {
                                            "application/json": [".json"],
                                        },
                                    },
                                ],
                            });
                            const writable = await handle.createWritable();
                            await writable.write(jsonContent);
                            await writable.close();
                            showSaveIndicator("Project exported!");
                            return;
                        } catch (err) {
                            if (err.name !== "AbortError")
                                console.log("Save picker failed:", err);
                            return;
                        }
                    }

                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `editr-project-${tabId}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showSaveIndicator("Project downloaded!");
                }

                async function importProject() {
                    if ("showOpenFilePicker" in window) {
                        try {
                            const [handle] = await window.showOpenFilePicker({
                                multiple: false,
                                types: [
                                    {
                                        description: "Editr Project files",
                                        accept: {
                                            "application/json": [".json"],
                                        },
                                    },
                                ],
                            });
                            const file = await handle.getFile();
                            const content = await file.text();
                            await processProjectImport(content);
                        } catch (err) {
                            if (err.name !== "AbortError")
                                console.log("File picker failed:", err);
                        }
                    } else {
                        const input = document.createElement("input");
                        input.type = "file";
                        input.accept = ".json";
                        input.addEventListener("change", async (e) => {
                            if (e.target.files[0]) {
                                const file = e.target.files[0];
                                const content = await file.text();
                                await processProjectImport(content);
                            }
                        });
                        input.click();
                    }
                }

                async function processProjectImport(jsonContent) {
                    try {
                        const projectData = JSON.parse(jsonContent);

                        if (
                            !projectData.version ||
                            !projectData.buffers ||
                            !projectData.tabId
                        ) {
                            alert("Invalid or corrupted project file.");
                            return;
                        }

                        const confirmImport = confirm(
                            "Importing this project will replace your current buffers in this tab. Are you sure you want to continue?",
                        );

                        if (confirmImport) {
                            buffers = projectData.buffers.map((b) => {
                                const buffer = new FileBuffer(
                                    b.name,
                                    b.content,
                                    null,
                                    b.isLocked,
                                    b.encryptedContent,
                                    b.salt,
                                    b.iv,
                                );
                                buffer.isGridView = b.isGridView || false;
                                return buffer;
                            });
                            activeBufferIndex =
                                projectData.activeBufferIndex || 0;
                            if (activeBufferIndex >= buffers.length)
                                activeBufferIndex = 0;

                            if (projectData.expansions) {
                                expansions = projectData.expansions;
                                saveExpansions();
                            }

                            saveBuffersToLocalStorage();
                            updateBufferBar();
                            loadActiveBuffer();

                            showSaveIndicator("Project imported successfully!");
                        }
                    } catch (error) {
                        console.error("Failed to import project:", error);
                        alert(
                            "Failed to import project. The file may be invalid.",
                        );
                    }
                }

                function newTab() {
                    const newId = Math.random().toString(36).substr(2, 6);
                    const newUrl = `${window.location.origin}${window.location.pathname}#${newId}`;
                    window.open(newUrl, "_blank");
                }

                function toggleFullscreen() {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        document.exitFullscreen();
                    }
                }

                function showContextMenu(x, y) {
                    const menuWidth = contextMenu.offsetWidth;
                    const menuHeight = contextMenu.offsetHeight;

                    if (x + menuWidth > window.innerWidth)
                        x = window.innerWidth - menuWidth - 10;
                    if (y + menuHeight > window.innerHeight)
                        y = window.innerHeight - menuHeight - 10;
                    x = Math.max(10, x);
                    y = Math.max(10, y);

                    contextMenu.style.left = `${x}px`;
                    contextMenu.style.top = `${y}px`;
                    contextMenu.style.display = "block";

                    const submenus = document.querySelectorAll(".submenu");
                    submenus.forEach((submenu) => {
                        submenu.classList.remove("open-left");
                        const parentRect =
                            submenu.parentElement.getBoundingClientRect();
                        if (
                            parentRect.right + submenu.offsetWidth >
                            window.innerWidth
                        ) {
                            submenu.classList.add("open-left");
                        }
                    });
                }

                function hideContextMenu() {
                    contextMenu.style.display = "none";
                    contextMenu.classList.remove("mobile-menu");
                    contextMenu
                        .querySelectorAll(".context-menu-item.open")
                        .forEach((item) => {
                            item.classList.remove("open");
                        });
                }

                function showHelp() {
                    helpModal.classList.remove("hidden");
                    if (!document.getElementById("modalBackdrop")) {
                        document.body.insertAdjacentHTML(
                            "beforeend",
                            '<div id="modalBackdrop" class="modal-backdrop"></div>',
                        );
                        document
                            .getElementById("modalBackdrop")
                            .addEventListener("click", closeHelpModal);
                    }
                }

                function closeHelpModal() {
                    helpModal.classList.add("hidden");
                    const backdrop = document.getElementById("modalBackdrop");
                    if (backdrop) backdrop.remove();
                    editor.focus();
                }

                function openExpansionsModal() {
                    expansionsList.innerHTML = "";
                    const sortedKeys = Object.keys(expansions).sort();
                    sortedKeys.forEach((key) => {
                        const item = document.createElement("div");
                        item.className = "expansion-item";
                        const label = document.createElement("label");
                        label.textContent = key;
                        label.htmlFor = `exp-input-${key}`;
                        const input = document.createElement("input");
                        input.type = "text";
                        input.id = `exp-input-${key}`;
                        input.dataset.key = key;
                        input.value = expansions[key];
                        item.appendChild(label);
                        item.appendChild(input);
                        expansionsList.appendChild(item);
                    });
                    expansionsModal.classList.remove("hidden");
                    if (!document.getElementById("modalBackdrop")) {
                        document.body.insertAdjacentHTML(
                            "beforeend",
                            '<div id="modalBackdrop" class="modal-backdrop"></div>',
                        );
                        document
                            .getElementById("modalBackdrop")
                            .addEventListener("click", closeExpansionsModal);
                    }
                }

                function closeExpansionsModal() {
                    expansionsModal.classList.add("hidden");
                    const backdrop = document.getElementById("modalBackdrop");
                    if (backdrop) backdrop.remove();
                    editor.focus();
                }

                function openFindDialog() {
                    findReplaceDialog.classList.remove("hidden");
                    const selectedText = editor.value.substring(
                        editor.selectionStart,
                        editor.selectionEnd,
                    );
                    findInput.value = selectedText || lastSearch.term || "";
                    setTimeout(() => {
                        findInput.focus();
                        findInput.select();
                    }, 0);
                }

                function closeFindDialog() {
                    findReplaceDialog.classList.add("hidden");
                    editor.focus();
                }

                function find(isForward) {
                    const searchTerm = findInput.value;
                    if (!searchTerm) return;
                    if (lastSearch.term !== searchTerm) lastMatch = null;
                    lastSearch.term = searchTerm;
                    const text = editor.value;
                    const lowerCaseText = text.toLowerCase();
                    const lowerCaseSearchTerm = searchTerm.toLowerCase();
                    let foundIndex = -1;
                    let wrapped = false;
                    if (isForward) {
                        const startPos = lastMatch
                            ? lastMatch.end
                            : editor.selectionEnd;
                        foundIndex = lowerCaseText.indexOf(
                            lowerCaseSearchTerm,
                            startPos,
                        );
                        if (foundIndex === -1) {
                            wrapped = true;
                            foundIndex = lowerCaseText.indexOf(
                                lowerCaseSearchTerm,
                                0,
                            );
                        }
                    } else {
                        const startPos = lastMatch
                            ? lastMatch.start
                            : editor.selectionStart;
                        foundIndex = lowerCaseText.lastIndexOf(
                            lowerCaseSearchTerm,
                            startPos - 1,
                        );
                        if (foundIndex === -1) {
                            wrapped = true;
                            foundIndex =
                                lowerCaseText.lastIndexOf(lowerCaseSearchTerm);
                        }
                    }
                    if (foundIndex !== -1) {
                        if (
                            lastMatch &&
                            lastMatch.start === foundIndex &&
                            wrapped
                        ) {
                            showSaveIndicator("Term not found", true);
                            lastMatch = null;
                        } else {
                            const matchEnd = foundIndex + searchTerm.length;
                            editor.setSelectionRange(foundIndex, matchEnd);
                            lastMatch = { start: foundIndex, end: matchEnd };
                            const textToSelection = text.substring(
                                0,
                                foundIndex,
                            );
                            const lineNumber = (
                                textToSelection.match(/\n/g) || []
                            ).length;
                            const computedStyle =
                                window.getComputedStyle(editor);
                            const lineHeight = parseFloat(
                                computedStyle.lineHeight,
                            );
                            const scrollTop =
                                lineNumber * lineHeight -
                                editor.clientHeight / 3;
                            editor.scrollTop = Math.max(0, scrollTop);
                            if (wrapped)
                                showSaveIndicator(
                                    "Find: Wrapped around document",
                                );
                        }
                    } else {
                        showSaveIndicator("Term not found", true);
                        lastMatch = null;
                        findInput.focus();
                        findInput.select();
                        return;
                    }
                    editor.focus();
                }

                function replace() {
                    const searchTerm = findInput.value;
                    const replaceTerm = replaceInput.value;
                    if (!searchTerm) return;
                    const selection = editor.value.substring(
                        editor.selectionStart,
                        editor.selectionEnd,
                    );
                    if (selection.toLowerCase() === searchTerm.toLowerCase()) {
                        editor.setRangeText(
                            replaceTerm,
                            editor.selectionStart,
                            editor.selectionEnd,
                            "end",
                        );
                        lastMatch = null;
                    }
                    find(true);
                }

                function replaceAll() {
                    const searchTerm = findInput.value;
                    const replaceTerm = replaceInput.value;
                    if (!searchTerm) return;
                    const regex = new RegExp(
                        searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"),
                        "gi",
                    );
                    const originalValue = editor.value;
                    let changes = 0;
                    const newValue = originalValue.replace(regex, (match) => {
                        changes++;
                        return replaceTerm;
                    });
                    if (changes > 0) {
                        editor.value = newValue;
                        lastMatch = null;
                        editor.dispatchEvent(new Event("input"));
                        showSaveIndicator(`Replaced ${changes} occurrence(s)`);
                    } else {
                        showSaveIndicator("Term not found", true);
                    }
                }

                // --- New Feature Functions ---

                function updatePreview() {
                    if (previewPane.classList.contains("hidden")) return;
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer || buffer.isSpecial || buffer.isGridView) {
                        previewPane.innerHTML = "";
                        return;
                    }
                    const dirtyHTML = marked.parse(editor.value);
                    const cleanHTML = DOMPurify.sanitize(dirtyHTML);
                    previewPane.innerHTML = `<div class="markdown-body">${cleanHTML}</div>`;
                }

                function togglePreview() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer || buffer.isSpecial || buffer.isGridView) {
                        showSaveIndicator(
                            "Preview not available for this buffer type.",
                            true,
                        );
                        return;
                    }
                    const isActive =
                        document.body.classList.toggle("split-view-active");
                    previewPane.classList.toggle("hidden", !isActive);
                    localStorage.setItem("previewActive", isActive);
                    if (isActive) {
                        updatePreview();
                    }
                }

                function exportAsHTML() {
                    const buffer = buffers[activeBufferIndex];
                    if (
                        !buffer ||
                        buffer.isSpecial ||
                        buffer.isGridView ||
                        buffer.isLocked
                    ) {
                        showSaveIndicator(
                            "Cannot export this buffer type as HTML.",
                            true,
                        );
                        return;
                    }

                    const content = editor.value;
                    const title = buffer.name.replace(/\.[^/.]+$/, "");
                    const renderedHTML = DOMPurify.sanitize(
                        marked.parse(content),
                    );
                    const isDarkMode =
                        !document.body.classList.contains("light-mode");

                    const htmlTemplate = `
                  <!DOCTYPE html>
                  <html lang="en">
                  <head>
                      <meta charset="UTF-8">
                      <meta name="viewport" content="width=device-width, initial-scale=1.0">
                      <title>${title}</title>
                      <style>
                          body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 20px 40px; margin: 0; }
                          .markdown-body { max-width: 800px; margin: 0 auto; }
                          body.dark-mode { background-color: #0d1117; color: #c9d1d9; }
                          .dark-mode .markdown-body h1, .dark-mode .markdown-body h2 { border-bottom-color: #21262d; }
                          .dark-mode .markdown-body a { color: #58a6ff; }
                          .dark-mode .markdown-body blockquote { color: #8b949e; border-left-color: #30363d; }
                          .dark-mode .markdown-body code { background-color: rgba(110,118,129,0.4); }
                          .dark-mode .markdown-body pre { background-color: #161b22; }
                          .dark-mode .markdown-body tr { background-color: #161b22; border-top-color: #21262d; }
                          .dark-mode .markdown-body th, .dark-mode .markdown-body td { border-color: #30363d; }
                          /* Styles from style.css for light mode can be copied here for consistency if desired */
                      </style>
                  </head>
                  <body class="${isDarkMode ? "dark-mode" : ""}">
                      <div class="markdown-body">
                          ${renderedHTML}
                      </div>
                  </body>
                  </html>`;

                    const blob = new Blob([htmlTemplate.trim()], {
                        type: "text/html",
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `${title}.html`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showSaveIndicator("HTML file downloaded!");
                }

                function exportAsPDF() {
                    const buffer = buffers[activeBufferIndex];
                    if (
                        !buffer ||
                        buffer.isSpecial ||
                        buffer.isGridView ||
                        buffer.isLocked
                    ) {
                        showSaveIndicator(
                            "Cannot export this buffer type as PDF.",
                            true,
                        );
                        return;
                    }

                    showSaveIndicator("Generating PDF...");

                    const content = editor.value;
                    const title = buffer.name.replace(/\.[^/.]+$/, "");
                    const renderedHTML = DOMPurify.sanitize(
                        marked.parse(content),
                    );

                    // Create a temporary element to render for the PDF
                    const printElement = document.createElement("div");
                    printElement.innerHTML = `
                  <style>
                      body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; line-height: 1.6; }
                      .markdown-body { max-width: 800px; margin: 0 auto; color: #000; } /* PDF text should be dark */
                      h1, h2 { border-bottom: 1px solid #eaecef; } a { color: #0366d6; text-decoration: none; }
                      blockquote { color: #6a737d; border-left: 0.25em solid #dfe2e5; padding: 0 1em; }
                      code { background-color: rgba(27,31,35,.05); font-family: monospace; padding: .2em .4em; font-size: 85%; border-radius: 6px; }
                      pre { background-color: #f6f8fa; font-family: monospace; padding: 16px; overflow: auto; line-height: 1.45; border-radius: 6px; }
                      table { border-collapse: collapse; } tr { border-top: 1px solid #c6cbd1; } th, td { border: 1px solid #d0d7de; padding: 6px 13px; }
                  </style>
                  <div class="markdown-body">${renderedHTML}</div>
              `;

                    const opt = {
                        margin: 1,
                        filename: `${title}.pdf`,
                        image: { type: "jpeg", quality: 0.98 },
                        html2canvas: { scale: 2 },
                        jsPDF: {
                            unit: "in",
                            format: "letter",
                            orientation: "portrait",
                        },
                    };

                    html2pdf().set(opt).from(printElement).save();
                }

                function openLinkFromCurrentLine() {
                    const cursorPos = editor.selectionStart;
                    const text = editor.value;
                    const lineStart = text.lastIndexOf("\n", cursorPos - 1) + 1;
                    let lineEnd = text.indexOf("\n", lineStart);
                    if (lineEnd === -1) lineEnd = text.length;
                    const currentLine = text.substring(lineStart, lineEnd);
                    const urlRegex = /https?:\/\/[^\s<>()"]+/;
                    const match = currentLine.match(urlRegex);
                    if (match && match[0]) {
                        try {
                            let url = match[0];
                            while (/[.,;!?]$/.test(url)) url = url.slice(0, -1);
                            new URL(url);
                            window.open(url, "_blank", "noopener,noreferrer");
                        } catch (_) {
                            showSaveIndicator(
                                "Invalid URL found on the current line.",
                                true,
                            );
                        }
                    } else {
                        showSaveIndicator(
                            "No URL found on the current line.",
                            true,
                        );
                    }
                }

                function emailBuffer() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;
                    if (buffer.isLocked) {
                        showSaveIndicator("Cannot email a locked note!", true);
                        return;
                    }
                    if (buffer.isSpecial) {
                        showSaveIndicator(
                            "Cannot email this type of buffer.",
                            true,
                        );
                        return;
                    }
                    const subject = `Note: ${buffer.name}`;
                    const body = buffer.content;
                    const mailtoLink = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                    window.location.href = mailtoLink;
                }

                function openCalculator() {
                    const existingIndex = buffers.findIndex(
                        (b) => b.name === CALC_BUFFER_NAME,
                    );
                    if (existingIndex !== -1) {
                        switchToBuffer(existingIndex);
                        return;
                    }
                    const content = `Welcome to the Editr Calculator!\nType a math expression (e.g., 5 * (10 + 2)) and press Enter.\n\n`;
                    const buffer = new FileBuffer(CALC_BUFFER_NAME, content);
                    buffer.isSpecial = true;
                    buffers.push(buffer);
                    switchToBuffer(buffers.length - 1);
                }

                function openCalendar() {
                    const existingIndex = buffers.findIndex(
                        (b) => b.name === CALENDAR_BUFFER_NAME,
                    );
                    if (existingIndex !== -1) {
                        switchToBuffer(existingIndex);
                        return;
                    }
                    const buffer = new FileBuffer(CALENDAR_BUFFER_NAME, "");
                    buffer.isSpecial = true;
                    buffer.calendarDate = new Date();
                    buffers.push(buffer);
                    switchToBuffer(buffers.length - 1);
                }

                function generateCalendarView(date) {
                    const now = new Date();
                    const timeString = now.toLocaleTimeString();
                    const dateString = now.toLocaleDateString(undefined, {
                        weekday: "long",
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                    });
                    const month = date.getMonth();
                    const year = date.getFullYear();
                    const monthName = date.toLocaleString("default", {
                        month: "long",
                    });
                    let calendar = `..................................\n`;
                    calendar += `${dateString}\n`;
                    calendar += `${timeString}\n`;
                    calendar += `..................................\n\n`;
                    calendar += `     ${monthName} ${year}\n`;
                    calendar += `Su Mo Tu We Th Fr Sa\n`;
                    const firstDayOfMonth = new Date(year, month, 1).getDay();
                    const daysInMonth = new Date(year, month + 1, 0).getDate();
                    let line = " ".repeat(firstDayOfMonth * 3);
                    for (let day = 1; day <= daysInMonth; day++) {
                        line += day.toString().padStart(2, " ") + " ";
                        if (
                            (day + firstDayOfMonth) % 7 === 0 ||
                            day === daysInMonth
                        ) {
                            calendar += line.trimEnd() + "\n";
                            line = "";
                        }
                    }
                    calendar += `\n..................................\n`;
                    calendar += `Controls: 'n' for next month, 'p' for previous month.\n`;
                    return calendar;
                }

                function handleTextExpansion(e) {
                    if (e.key !== " " && e.key !== "Enter" && e.key !== "Tab")
                        return;
                    const cursorPos = editor.selectionStart;
                    const textBeforeCursor = editor.value.substring(
                        0,
                        cursorPos,
                    );
                    const lastSpaceIndex = textBeforeCursor.lastIndexOf(" ");
                    const lastNewlineIndex = textBeforeCursor.lastIndexOf("\n");
                    const lastWordStartIndex =
                        Math.max(lastSpaceIndex, lastNewlineIndex) + 1;
                    const potentialShortcut =
                        textBeforeCursor.substring(lastWordStartIndex);
                    if (
                        potentialShortcut.length < 2 ||
                        !potentialShortcut.startsWith(".")
                    )
                        return;
                    let expansionText = "";
                    if (potentialShortcut === ".d") {
                        const today = new Date();
                        const year = today.getFullYear();
                        const month = String(today.getMonth() + 1).padStart(
                            2,
                            "0",
                        );
                        const day = String(today.getDate()).padStart(2, "0");
                        expansionText = `${year}${month}${day}`;
                    } else if (
                        expansions.hasOwnProperty(potentialShortcut) &&
                        expansions[potentialShortcut]
                    ) {
                        expansionText = expansions[potentialShortcut];
                    }
                    if (expansionText) {
                        e.preventDefault();
                        editor.setRangeText(
                            expansionText,
                            lastWordStartIndex,
                            cursorPos,
                            "end",
                        );
                        if (e.key === " ")
                            editor.setRangeText(
                                " ",
                                editor.selectionStart,
                                editor.selectionEnd,
                                "end",
                            );
                        else if (e.key === "Enter")
                            editor.setRangeText(
                                "\n",
                                editor.selectionStart,
                                editor.selectionEnd,
                                "end",
                            );
                        editor.dispatchEvent(
                            new Event("input", { bubbles: true }),
                        );
                    }
                }

                function handleAutoClosingBrackets(e) {
                    const key = e.key;
                    const editor = e.target;
                    const start = editor.selectionStart;
                    const end = editor.selectionEnd;
                    let openChar = null;
                    let closeChar = null;
                    if (key === "(") {
                        openChar = "(";
                        closeChar = ")";
                    } else if (key === "[") {
                        openChar = "[";
                        closeChar = "]";
                    } else if (key === "{") {
                        openChar = "{";
                        closeChar = "}";
                    } else if (key === "<") {
                        openChar = "<";
                        closeChar = ">";
                    }
                    if (openChar) {
                        e.preventDefault();
                        if (start !== end) {
                            const selectedText = editor.value.substring(
                                start,
                                end,
                            );
                            const textToInsert =
                                openChar + selectedText + closeChar;
                            editor.setRangeText(
                                textToInsert,
                                start,
                                end,
                                "select",
                            );
                        } else {
                            const textToInsert = openChar + closeChar;
                            editor.setRangeText(
                                textToInsert,
                                start,
                                end,
                                "end",
                            );
                            editor.selectionStart = editor.selectionEnd =
                                start + 1;
                        }
                        editor.dispatchEvent(
                            new Event("input", { bubbles: true }),
                        );
                    }
                }

                function handleAutoIndent(e) {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        const cursorPos = editor.selectionStart;
                        const textBefore = editor.value.substring(0, cursorPos);
                        const lineBefore = textBefore.substring(
                            textBefore.lastIndexOf("\n") + 1,
                        );
                        const indent = lineBefore.match(/^\s*/)[0];
                        editor.setRangeText(
                            "\n" + indent,
                            cursorPos,
                            cursorPos,
                            "end",
                        );
                    }
                }

                function handleBracketMatching(e) {
                    if (Object.values(bracketPairs).includes(e.key)) {
                        const cursorPos = editor.selectionStart;
                        const text = editor.value;
                        let stack = [e.key];
                        let openerIndex = -1;
                        for (let i = cursorPos - 2; i >= 0; i--) {
                            if (Object.values(bracketPairs).includes(text[i])) {
                                stack.push(text[i]);
                            } else if (
                                Object.keys(bracketPairs).includes(text[i])
                            ) {
                                if (
                                    bracketPairs[text[i]] ===
                                    stack[stack.length - 1]
                                ) {
                                    stack.pop();
                                    if (stack.length === 0) {
                                        openerIndex = i;
                                        break;
                                    }
                                }
                            }
                        }
                        if (openerIndex !== -1) {
                            const tempSelectionStart = editor.selectionStart;
                            const tempSelectionEnd = editor.selectionEnd;
                            editor.setSelectionRange(
                                openerIndex,
                                openerIndex + 1,
                            );
                            setTimeout(() => {
                                editor.setSelectionRange(
                                    tempSelectionStart,
                                    tempSelectionEnd,
                                );
                            }, 200);
                        }
                    }
                }

                function handleCalculatorEvaluation() {
                    const cursorPos = editor.selectionStart;
                    const textUpToCursor = editor.value.substring(0, cursorPos);
                    const lastNewline = textUpToCursor.lastIndexOf("\n");
                    const currentLine = editor.value
                        .substring(lastNewline + 1, cursorPos)
                        .trim();
                    if (currentLine) {
                        try {
                            const sanitizedExpression = currentLine.replace(
                                /[^-()\d/*+.\s^]/g,
                                "",
                            );
                            const result = new Function(
                                "return " +
                                    sanitizedExpression.replace(/\^/g, "**"),
                            )();
                            editor.setRangeText(
                                ` = ${result}\n`,
                                cursorPos,
                                cursorPos,
                                "end",
                            );
                        } catch (error) {
                            editor.setRangeText(
                                ` = Error\n`,
                                cursorPos,
                                cursorPos,
                                "end",
                            );
                        }
                        editor.dispatchEvent(
                            new Event("input", { bubbles: true }),
                        );
                    }
                }

                function applyMarkdownFormatting(params) {
                    const { prefix, suffix = prefix, type = "wrap" } = params;
                    const start = editor.selectionStart;
                    const end = editor.selectionEnd;
                    const text = editor.value;

                    if (type === "wrap") {
                        const selectedText = text.substring(start, end);
                        const beforeSelection = text.substring(
                            start - prefix.length,
                            start,
                        );
                        const afterSelection = text.substring(
                            end,
                            end + suffix.length,
                        );

                        if (
                            beforeSelection === prefix &&
                            afterSelection === suffix
                        ) {
                            editor.setRangeText(
                                selectedText,
                                start - prefix.length,
                                end + suffix.length,
                                "select",
                            );
                        } else {
                            editor.setRangeText(
                                prefix + selectedText + suffix,
                                start,
                                end,
                                "select",
                            );
                            editor.selectionStart = start + prefix.length;
                            editor.selectionEnd = end + prefix.length;
                        }
                    } else if (type === "line") {
                        let lineStart = text.lastIndexOf("\n", start - 1) + 1;
                        let lineEnd = text.indexOf("\n", end);
                        if (lineEnd === -1) lineEnd = text.length;

                        const selectedLinesText = text.substring(
                            lineStart,
                            lineEnd,
                        );
                        const lines = selectedLinesText.split("\n");
                        const allLinesHavePrefix = lines.every(
                            (line) =>
                                line.startsWith(prefix) || line.trim() === "",
                        );

                        let newLines;
                        if (allLinesHavePrefix) {
                            newLines = lines.map((line) =>
                                line.startsWith(prefix)
                                    ? line.substring(prefix.length)
                                    : line,
                            );
                        } else {
                            let isNumberedList = /^\d+\. /.test(prefix);
                            let counter = 1;
                            if (isNumberedList) {
                                const textBefore = text.substring(
                                    0,
                                    lineStart - 1,
                                );
                                const lastLineBefore = textBefore.substring(
                                    textBefore.lastIndexOf("\n") + 1,
                                );
                                const match = lastLineBefore.match(/^(\d+)\. /);
                                if (match) counter = parseInt(match[1], 10) + 1;
                            }
                            newLines = lines.map((line) => {
                                if (line.trim() !== "") {
                                    let currentPrefix = isNumberedList
                                        ? `${counter++}. `
                                        : prefix;
                                    return currentPrefix + line;
                                }
                                return line;
                            });
                        }
                        const newText = newLines.join("\n");
                        editor.setRangeText(newText, lineStart, lineEnd, "end");
                    }
                }

                function loadFileContent(file) {
                    const reader = new FileReader();
                    reader.onload = (e) =>
                        createNewBuffer(file.name, e.target.result, null);
                    reader.readAsText(file);
                }

                // Event Listeners
                editor.addEventListener("input", function () {
                    lastMatch = null;
                    const buffer = buffers[activeBufferIndex];
                    if (buffer && !buffer.isLocked && !buffer.isSpecial) {
                        buffer.content = editor.value;
                        updateBufferBar();
                        saveBuffersToLocalStorage();
                    }
                    updateStatsDisplay();
                    updatePreview();
                });

                editor.addEventListener("keyup", updateStatsDisplay);
                editor.addEventListener("click", updateStatsDisplay);
                fileInput.addEventListener("change", (e) => {
                    if (e.target.files[0]) loadFileContent(e.target.files[0]);
                });
                findNextBtn.addEventListener("click", () => find(true));
                findPrevBtn.addEventListener("click", () => find(false));
                replaceBtn.addEventListener("click", replace);
                replaceAllBtn.addEventListener("click", replaceAll);
                closeFindBtn.addEventListener("click", closeFindDialog);
                findInput.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        find(!e.shiftKey);
                    }
                    if (e.key === "Escape") {
                        e.preventDefault();
                        closeFindDialog();
                    }
                });
                replaceInput.addEventListener("keydown", (e) => {
                    if (e.key === "Escape") {
                        e.preventDefault();
                        closeFindDialog();
                    }
                });
                saveExpansionsBtn.addEventListener("click", () => {
                    const inputs =
                        expansionsList.querySelectorAll("input[data-key]");
                    inputs.forEach((input) => {
                        const key = input.dataset.key;
                        if (expansions.hasOwnProperty(key))
                            expansions[key] = input.value;
                    });
                    saveExpansions();
                    showSaveIndicator("Expansions saved!");
                    closeExpansionsModal();
                });
                exportExpansionsBtn.addEventListener("click", () => {
                    const content = Object.entries(expansions)
                        .filter(([key, value]) => value)
                        .map(([key, value]) => `${key}=${value}`)
                        .join("\n");
                    const blob = new Blob([content], {
                        type: "text/plain;charset=utf-8",
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = "editr-expansions.txt";
                    a.click();
                    URL.revokeObjectURL(url);
                    showSaveIndicator("Expansions exported!");
                });
                importExpansionsBtn.addEventListener("click", () => {
                    importExpansionsInput.click();
                });
                importExpansionsInput.addEventListener("change", (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const content = event.target.result;
                        const lines = content.split("\n");
                        let importCount = 0;
                        lines.forEach((line) => {
                            const parts = line.split("=");
                            if (parts.length >= 2) {
                                const key = parts[0].trim();
                                const value = parts.slice(1).join("=").trim();
                                if (expansions.hasOwnProperty(key)) {
                                    expansions[key] = value;
                                    importCount++;
                                }
                            }
                        });
                        saveExpansions();
                        openExpansionsModal();
                        showSaveIndicator(
                            `Imported ${importCount} expansions!`,
                        );
                    };
                    reader.onerror = () => {
                        showSaveIndicator("Error reading file.", true);
                    };
                    reader.readAsText(file);
                    e.target.value = "";
                });
                closeExpansionsBtn.addEventListener(
                    "click",
                    closeExpansionsModal,
                );
                editor.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editor.classList.add("drag-over");
                });
                editor.addEventListener("dragleave", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!editor.contains(e.relatedTarget))
                        editor.classList.remove("drag-over");
                });
                editor.addEventListener("drop", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editor.classList.remove("drag-over");
                    if (e.dataTransfer.files.length > 0)
                        loadFileContent(e.dataTransfer.files[0]);
                });
                editor.addEventListener("keydown", (e) => {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;

                    const isModifierKey = e.ctrlKey || e.metaKey;

                    if (isModifierKey) {
                        let handled = true;
                        if (e.altKey && e.key >= "1" && e.key <= "6") {
                            applyMarkdownFormatting({
                                prefix: "#".repeat(parseInt(e.key)) + " ",
                                type: "line",
                            });
                        } else if (e.shiftKey) {
                            switch (e.key.toLowerCase()) {
                                case "x":
                                    applyMarkdownFormatting({ prefix: "~~" });
                                    break;
                                case "l":
                                    applyMarkdownFormatting({
                                        prefix: "- ",
                                        type: "line",
                                    });
                                    break;
                                case "o":
                                    applyMarkdownFormatting({
                                        prefix: "1. ",
                                        type: "line",
                                    });
                                    break;
                                case "k":
                                    applyMarkdownFormatting({
                                        prefix: "```\n",
                                        suffix: "\n```",
                                    });
                                    break;
                                default:
                                    handled = false;
                            }
                        } else {
                            switch (e.key.toLowerCase()) {
                                case "b":
                                    applyMarkdownFormatting({ prefix: "**" });
                                    break;
                                case "i":
                                    applyMarkdownFormatting({ prefix: "_" });
                                    break;
                                case "k":
                                    applyMarkdownFormatting({
                                        prefix: "[",
                                        suffix: "](url)",
                                    });
                                    break;
                                case "'":
                                    applyMarkdownFormatting({
                                        prefix: "> ",
                                        type: "line",
                                    });
                                    break;
                                case "`":
                                    applyMarkdownFormatting({ prefix: "`" });
                                    break;
                                default:
                                    handled = false;
                            }
                        }
                        if (handled) {
                            e.preventDefault();
                            return;
                        }
                    }

                    if (buffer.name === CALC_BUFFER_NAME && e.key === "Enter") {
                        e.preventDefault();
                        handleCalculatorEvaluation();
                        return;
                    }
                    if (buffer.name === CALENDAR_BUFFER_NAME) {
                        if (e.key === "n" || e.key === "p") {
                            e.preventDefault();
                            const currentDate = buffer.calendarDate;
                            const direction = e.key === "n" ? 1 : -1;
                            currentDate.setMonth(
                                currentDate.getMonth() + direction,
                            );
                            buffer.calendarDate = new Date(currentDate);
                            editor.value = generateCalendarView(
                                buffer.calendarDate,
                            );
                        }
                        return;
                    }
                    handleTextExpansion(e);
                    handleAutoClosingBrackets(e);
                    handleAutoIndent(e);
                });
                editor.addEventListener("keyup", handleBracketMatching);
                hamburgerBtn.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (contextMenu.style.display === "block") {
                        hideContextMenu();
                    } else {
                        const bufferList =
                            document.getElementById("ctxBufferList");
                        const bufferDivider =
                            document.getElementById("ctxBufferDivider");
                        bufferList.innerHTML = "";
                        if (buffers.length > 1) {
                            buffers.forEach((buf, index) => {
                                const item = document.createElement("div");
                                item.className = "context-menu-item";
                                item.textContent = `${index === activeBufferIndex ? "✓ " : "\u00A0\u00A0"}${index + 1}: ${buf.name}`;
                                item.title = buf.name;
                                item.addEventListener("click", () => {
                                    switchToBuffer(index);
                                    hideContextMenu();
                                });
                                bufferList.appendChild(item);
                            });
                            bufferDivider.style.display = "block";
                        } else {
                            bufferDivider.style.display = "none";
                        }
                        const buffer = buffers[activeBufferIndex];
                        document.getElementById(
                            "ctxBufferMenuLabel",
                        ).textContent = "Buffer";
                        document.getElementById(
                            "ctxToggleStats",
                        ).firstElementChild.textContent =
                            statsDisplay.classList.contains("hidden")
                                ? "Show Stats"
                                : "Hide Stats";
                        document.getElementById(
                            "ctxToggleFileName",
                        ).firstElementChild.textContent =
                            fileNameDisplay.classList.contains("hidden")
                                ? "Show File Name"
                                : "Hide File Name";
                        document.getElementById(
                            "ctxToggleLock",
                        ).firstElementChild.textContent =
                            buffer && buffer.isLocked
                                ? "Unlock Note"
                                : "Lock Note";
                        document.getElementById(
                            "ctxToggleDark",
                        ).firstElementChild.textContent =
                            document.body.classList.contains("light-mode")
                                ? "Light Mode"
                                : "Dark Mode";
                        document.getElementById(
                            "ctxToggleWrap",
                        ).firstElementChild.textContent =
                            editor.classList.contains("no-wrap")
                                ? "Enable Word Wrap"
                                : "Disable Word Wrap";
                        document.getElementById(
                            "ctxToggleFullscreen",
                        ).firstElementChild.textContent =
                            document.fullscreenElement
                                ? "Exit Fullscreen"
                                : "Fullscreen";
                        document.getElementById(
                            "ctxTogglePreview",
                        ).firstElementChild.textContent =
                            document.body.classList.contains(
                                "split-view-active",
                            )
                                ? "Hide Preview"
                                : "Show Preview";
                        contextMenu.classList.add("mobile-menu");
                        const rect = hamburgerBtn.getBoundingClientRect();
                        showContextMenu(rect.right - 280, rect.bottom + 5);
                    }
                });
                closeHelpBtn.addEventListener("click", closeHelpModal);
                document.addEventListener("keydown", async (e) => {
                    const activeEl = document.activeElement;
                    if (
                        activeEl.tagName === "INPUT" ||
                        activeEl.tagName === "TEXTAREA"
                    ) {
                        if (activeEl.id === "editor") {
                            // Let editor's own handler take precedence for markdown
                        } else {
                            // For find/replace, modals, etc., just handle Esc
                            if (e.key === "Escape") {
                                if (
                                    !findReplaceDialog.classList.contains(
                                        "hidden",
                                    )
                                )
                                    closeFindDialog();
                                if (
                                    !expansionsModal.classList.contains(
                                        "hidden",
                                    )
                                )
                                    closeExpansionsModal();
                            }
                            return; // Don't process global shortcuts
                        }
                    }

                    if (e.key === "?" && !e.shiftKey) {
                        e.preventDefault();
                        showHelp();
                        return;
                    }

                    if (e.altKey) {
                        let handled = true;
                        switch (e.key.toLowerCase()) {
                            case "z":
                                toggleWordWrap();
                                break;
                            case "h":
                                exportAsHTML();
                                break;
                            case "p":
                                exportAsPDF();
                                break;
                            case "f":
                                toggleFileNameDisplay();
                                break;
                            case "s":
                                toggleStats();
                                break;
                            case "c":
                                openCalendar();
                                break;
                            default:
                                handled = false;
                        }
                        if (handled) {
                            e.preventDefault();
                            return;
                        }
                    }

                    const buffer = buffers[activeBufferIndex];
                    if (buffer && buffer.isGridView && selectedGridCell) {
                        if (e.key.startsWith("Arrow")) {
                            e.preventDefault();
                            const currentRow = parseInt(
                                selectedGridCell.dataset.row,
                                10,
                            );
                            const currentCol = parseInt(
                                selectedGridCell.dataset.col,
                                10,
                            );
                            let nextCell;
                            if (e.key === "ArrowUp" && currentRow > 0)
                                nextCell = gridContent.querySelector(
                                    `[data-row="${currentRow - 1}"][data-col="${currentCol}"]`,
                                );
                            else if (e.key === "ArrowDown")
                                nextCell = gridContent.querySelector(
                                    `[data-row="${currentRow + 1}"][data-col="${currentCol}"]`,
                                );
                            else if (e.key === "ArrowLeft" && currentCol > 0)
                                nextCell = gridContent.querySelector(
                                    `[data-row="${currentRow}"][data-col="${currentCol - 1}"]`,
                                );
                            else if (e.key === "ArrowRight")
                                nextCell = gridContent.querySelector(
                                    `[data-row="${currentRow}"][data-col="${currentCol + 1}"]`,
                                );
                            if (nextCell) {
                                selectedGridCell.classList.remove("selected");
                                selectedGridCell = nextCell;
                                selectedGridCell.classList.add("selected");
                                selectedGridCell.focus();
                            }
                            return;
                        }
                    }

                    const isModifierKey = e.ctrlKey || e.metaKey;
                    if (isModifierKey) {
                        if (
                            e.shiftKey &&
                            document.activeElement.tagName !== "TEXTAREA"
                        ) {
                            let handled = true;
                            switch (e.key.toLowerCase()) {
                                case "g":
                                    toggleGridView();
                                    break;
                                case "c":
                                    openCalculator();
                                    break;
                                case "m":
                                    emailBuffer();
                                    break;
                                case "e":
                                    exportProject();
                                    break;
                                case "i":
                                    importProject();
                                    break;
                                default:
                                    handled = false;
                            }
                            if (handled) {
                                e.preventDefault();
                                return;
                            }
                        }

                        if (e.key >= "1" && e.key <= "9") {
                            e.preventDefault();
                            switchToBuffer(parseInt(e.key) - 1);
                            return;
                        }
                        if (e.key === "ArrowLeft") {
                            e.preventDefault();
                            const prevIndex =
                                activeBufferIndex > 0
                                    ? activeBufferIndex - 1
                                    : buffers.length - 1;
                            switchToBuffer(prevIndex);
                            return;
                        }
                        if (e.key === "ArrowRight") {
                            e.preventDefault();
                            const nextIndex =
                                activeBufferIndex < buffers.length - 1
                                    ? activeBufferIndex + 1
                                    : 0;
                            switchToBuffer(nextIndex);
                            return;
                        }
                        switch (e.key.toLowerCase()) {
                            case "f":
                                e.preventDefault();
                                openFindDialog();
                                break;
                            case "s":
                                e.preventDefault();
                                saveFile();
                                break;
                            case "d":
                                e.preventDefault();
                                toggleLightMode();
                                break;
                            case "o":
                                e.preventDefault();
                                openFile();
                                break;
                            case "n":
                                e.preventDefault();
                                newTab();
                                break;
                            case "l":
                                e.preventDefault();
                                openLinkFromCurrentLine();
                                break;
                            case "e":
                                e.preventDefault();
                                openExpansionsModal();
                                break;
                            case "w":
                                e.preventDefault();
                                closeBuffer(activeBufferIndex);
                                break;
                            case "=":
                                e.preventDefault();
                                await toggleLock();
                                break;
                            case "m":
                                e.preventDefault();
                                togglePreview();
                                break;
                        }
                    } else if (e.key === "F11") {
                        e.preventDefault();
                        toggleFullscreen();
                    } else if (e.key === "Escape") {
                        if (!helpModal.classList.contains("hidden"))
                            closeHelpModal();
                        if (contextMenu.style.display === "block")
                            hideContextMenu();
                    }
                });
                document.addEventListener("contextmenu", (e) => {
                    e.preventDefault();
                    const bufferList = document.getElementById("ctxBufferList");
                    const bufferDivider =
                        document.getElementById("ctxBufferDivider");
                    bufferList.innerHTML = "";
                    if (buffers.length > 1) {
                        buffers.forEach((buf, index) => {
                            const item = document.createElement("div");
                            item.className = "context-menu-item";
                            item.textContent = `${index === activeBufferIndex ? "✓ " : "\u00A0\u00A0"}${index + 1}: ${buf.name}`;
                            item.title = buf.name;
                            item.addEventListener("click", () => {
                                switchToBuffer(index);
                                hideContextMenu();
                            });
                            bufferList.appendChild(item);
                        });
                        bufferDivider.style.display = "block";
                    } else {
                        bufferDivider.style.display = "none";
                    }
                    const buffer = buffers[activeBufferIndex];
                    document.getElementById("ctxBufferMenuLabel").textContent =
                        "Buffer";
                    document.getElementById(
                        "ctxToggleStats",
                    ).firstElementChild.textContent =
                        statsDisplay.classList.contains("hidden")
                            ? "Show Stats"
                            : "Hide Stats";
                    document.getElementById(
                        "ctxToggleFileName",
                    ).firstElementChild.textContent =
                        fileNameDisplay.classList.contains("hidden")
                            ? "Show File Name"
                            : "Hide File Name";
                    document.getElementById(
                        "ctxToggleLock",
                    ).firstElementChild.textContent =
                        buffer && buffer.isLocked ? "Unlock Note" : "Lock Note";
                    document.getElementById(
                        "ctxToggleDark",
                    ).firstElementChild.textContent =
                        document.body.classList.contains("light-mode")
                            ? "Light Mode"
                            : "Dark Mode";
                    document.getElementById(
                        "ctxToggleWrap",
                    ).firstElementChild.textContent = editor.classList.contains(
                        "no-wrap",
                    )
                        ? "Enable Word Wrap"
                        : "Disable Word Wrap";
                    document.getElementById(
                        "ctxToggleFullscreen",
                    ).firstElementChild.textContent = document.fullscreenElement
                        ? "Exit Fullscreen"
                        : "Fullscreen";
                    document.getElementById(
                        "ctxTogglePreview",
                    ).firstElementChild.textContent =
                        document.body.classList.contains("split-view-active")
                            ? "Hide Preview"
                            : "Show Preview";
                    showContextMenu(e.clientX, e.clientY);
                });
                contextMenu.addEventListener("click", (e) => {
                    if (!contextMenu.classList.contains("mobile-menu")) return;
                    const menuItem = e.target.closest(
                        ".context-menu-item.has-submenu",
                    );
                    if (menuItem) {
                        e.preventDefault();
                        e.stopPropagation();
                        const siblings = menuItem.parentElement.children;
                        for (const sibling of siblings) {
                            if (
                                sibling !== menuItem &&
                                sibling.classList.contains("has-submenu")
                            )
                                sibling.classList.remove("open");
                        }
                        menuItem.classList.toggle("open");
                    }
                });
                document.addEventListener("click", (e) => {
                    if (
                        !contextMenu.contains(e.target) &&
                        !hamburgerBtn.contains(e.target) &&
                        contextMenu.style.display === "block"
                    )
                        hideContextMenu();
                });
                document.addEventListener("touchstart", (e) => {
                    if (
                        !contextMenu.contains(e.target) &&
                        !hamburgerBtn.contains(e.target) &&
                        contextMenu.style.display === "block"
                    )
                        hideContextMenu();
                });
                gridContent.addEventListener("focusin", (e) => {
                    if (e.target.tagName === "TD") {
                        if (selectedGridCell)
                            selectedGridCell.classList.remove("selected");
                        selectedGridCell = e.target;
                        selectedGridCell.classList.add("selected");
                    }
                });
                gridContent.addEventListener("input", () => {
                    const buffer = buffers[activeBufferIndex];
                    if (buffer && buffer.isGridView) {
                        gridToContent(buffer);
                        updateBufferBar();
                        saveBuffersToLocalStorage();
                        updateStatsDisplay();
                    }
                });
                addRowBtn.addEventListener("click", addGridRow);
                addColBtn.addEventListener("click", addGridColumn);
                delRowBtn.addEventListener("click", deleteGridRow);
                delColBtn.addEventListener("click", deleteGridColumn);
                document
                    .getElementById("ctxFindReplace")
                    .addEventListener("click", () => {
                        openFindDialog();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxManageExpansions")
                    .addEventListener("click", () => {
                        openExpansionsModal();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxNewTab")
                    .addEventListener("click", () => {
                        newTab();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxOpenFile")
                    .addEventListener("click", () => {
                        openFile();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxSaveFile")
                    .addEventListener("click", () => {
                        saveFile();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxExportHTML")
                    .addEventListener("click", () => {
                        exportAsHTML();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxExportPDF")
                    .addEventListener("click", () => {
                        exportAsPDF();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxExportProject")
                    .addEventListener("click", () => {
                        exportProject();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxImportProject")
                    .addEventListener("click", () => {
                        importProject();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxCloseBuffer")
                    .addEventListener("click", () => {
                        closeBuffer(activeBufferIndex);
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleLock")
                    .addEventListener("click", async () => {
                        await toggleLock();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleGridView")
                    .addEventListener("click", () => {
                        toggleGridView();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleDark")
                    .addEventListener("click", () => {
                        toggleLightMode();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleWrap")
                    .addEventListener("click", () => {
                        toggleWordWrap();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleFileName")
                    .addEventListener("click", () => {
                        toggleFileNameDisplay();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleStats")
                    .addEventListener("click", () => {
                        toggleStats();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxTogglePreview")
                    .addEventListener("click", () => {
                        togglePreview();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleFullscreen")
                    .addEventListener("click", () => {
                        toggleFullscreen();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxShowHelp")
                    .addEventListener("click", () => {
                        showHelp();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxNextBuffer")
                    .addEventListener("click", () => {
                        const nextIndex =
                            activeBufferIndex < buffers.length - 1
                                ? activeBufferIndex + 1
                                : 0;
                        switchToBuffer(nextIndex);
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxPrevBuffer")
                    .addEventListener("click", () => {
                        const prevIndex =
                            activeBufferIndex > 0
                                ? activeBufferIndex - 1
                                : buffers.length - 1;
                        switchToBuffer(prevIndex);
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxOpenLink")
                    .addEventListener("click", () => {
                        openLinkFromCurrentLine();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxCalculator")
                    .addEventListener("click", () => {
                        openCalculator();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxCalendar")
                    .addEventListener("click", () => {
                        openCalendar();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxEmailBuffer")
                    .addEventListener("click", () => {
                        emailBuffer();
                        hideContextMenu();
                    });

                window.addEventListener("hashchange", handleHashChange);
                initializeTabAndUrl();
                initializeBuffers();
                loadSettings();
                loadExpansions();
                handleLaunchedFiles(); // Handle files opened on launch
            });
        </script>

        <script>
            if ("serviceWorker" in navigator) {
                window.addEventListener("load", () => {
                    navigator.serviceWorker
                        .register("/sw.js")
                        .then((registration) => {
                            console.log(
                                "Service Worker registered with scope:",
                                registration.scope,
                            );
                        })
                        .catch((error) => {
                            console.log(
                                "Service Worker registration failed:",
                                error,
                            );
                        });
                });
            }
        </script>
    </body>
</html>
