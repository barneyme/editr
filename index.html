<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>editr</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSIjMDAwMDAwIi8+Cjx0ZXh0IHg9IjE2IiB5PSIyMiIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjE4IiBmb250LXdlaWdodD0iNDAwIiBmaWxsPSIjZmZmZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5lPC90ZXh0Pgo8L3N2Zz4K" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: #1e1e1e; color: #e0e0e0; height: 100vh; overflow: hidden; }
        .header { background: #2d2d30; border-bottom: 1px solid #3e3e42; padding: 8px 16px; display: flex; align-items: center; gap: 12px; }
        .logo { font-weight: 600; color: #2563eb; }
        .toolbar { display: flex; gap: 8px; align-items: center; }
        .btn { background: #3c3c3c; border: 1px solid #555; color: #e0e0e0; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .main-container { display: flex; height: calc(100vh - 50px); }
        .content-area { flex: 1; display: flex; flex-direction: column; }
        .editor-container { flex: 1; display: flex; }
        .editor-wrapper { flex: 1; position: relative; }
        .tabs-container { background: #2d2d30; border-bottom: 1px solid #3e3e42; display: flex; overflow-x: auto; min-height: 36px; }
        .tab { display: flex; align-items: center; padding: 8px 16px; border-right: 1px solid #3e3e42; cursor: pointer; font-size: 13px; white-space: nowrap; background: #1e1e1e; color: #cccccc; }
        .tab.active { background: #1e1e1e; color: #ffffff; border-bottom: 2px solid #2563eb; }
        .editor { width: 100%; height: 100%; border: none; background: #1e1e1e; color: #e0e0e0; font-family: 'Courier New', Monaco, 'Lucida Console', monospace; font-size: 14px; padding: 16px; resize: none; outline: none; }
        .preview-pane { width: 50%; background: #ffffff; color: #333; overflow-y: auto; padding: 16px; border-left: 1px solid #3e3e42; display: none; }
        .preview-pane.active { display: block; }
        .csv-grid-container { width: 100%; height: 100%; overflow: auto; background: #1e1e1e; display: none; }
        .grid-mode-active .editor { display: none; }
        .grid-mode-active .csv-grid-container { display: block; }
        .csv-grid { width: 100%; border-collapse: collapse; font-size: 12px; }
        .csv-grid th, .csv-grid td { border: 1px solid #3e3e42; padding: 0; text-align: left; }
        .csv-grid th { background: #2d2d30; font-weight: 600; padding: 4px 8px; }
        .csv-grid-input { width: 100%; height: 100%; background: transparent; border: none; color: inherit; font: inherit; padding: 4px 8px; outline: none; }
        .csv-grid-input:focus { background-color: #3c3c3c; }
        .status-bar { background: #2d2d30; border-top: 1px solid #3e3e42; padding: 4px 16px; font-size: 11px; color: #cccccc; display: flex; justify-content: space-between; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); }
        .modal-content { background: #2d2d30; margin: 10% auto; padding: 20px; border: 1px solid #3e3e42; border-radius: 6px; width: 400px; color: #e0e0e0; }
        .input-group { margin-bottom: 12px; }
        .input-group label { display: block; margin-bottom: 4px; }
        .input-group input, .input-group textarea { width: 100%; padding: 8px; background: #1e1e1e; border: 1px solid #555; color: #e0e0e0; }
        .modal-buttons { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }
        .text-modal-actions { display: flex; gap: 8px; margin-top: 12px; }
        .expander-item { display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; background: #252526; }
        .expander-item span { white-space: pre; overflow: hidden; text-overflow: ellipsis; }
        .delete-expander { cursor: pointer; flex-shrink: 0; margin-left: 10px; }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">editr</div>
        <div class="toolbar">
            <button class="btn" id="newFileBtn" title="New File (Ctrl+N)">New</button>
            <button class="btn" id="openFileBtn" title="Open File (Ctrl+O)">Open</button>
            <button class="btn" id="saveFileBtn" title="Save File (Ctrl+S)">Save</button>
            <button class="btn" id="saveAsFileBtn" title="Save As (Ctrl+Shift+S)">Save As</button>
            <button class="btn" id="previewBtn" style="display: none;" title="Toggle Preview (Ctrl+P)">Preview</button>
            <button class="btn" id="gridModeBtn" style="display: none;" title="Toggle Grid Mode (Ctrl+G)">Grid</button>
            <button class="btn" id="pdfBtn" style="display: none;" title="Export to PDF">PDF</button>
            <button class="btn" id="htmlBtn" style="display: none;" title="Export to HTML">HTML</button>
            <button class="btn" id="textBtn" title="Text Expansions (Ctrl+E)">Text</button>
        </div>
    </div>
    <div class="main-container">
        <div class="content-area">
            <div class="tabs-container" id="tabsContainer"></div>
            <div class="editor-container" id="editorContainer">
                <div class="editor-wrapper" id="editorWrapper">
                    <textarea class="editor" id="editor"></textarea>
                    <div class="csv-grid-container" id="csvGridContainer">
                        <table class="csv-grid" id="csvGrid"></table>
                    </div>
                </div>
                <div class="preview-pane" id="previewPane"></div>
            </div>
        </div>
    </div>
    <div class="status-bar">
        <span id="statusText">Ready</span>
        <span id="cursorPosition">Ln 1, Col 1</span>
    </div>
    <div id="textModal" class="modal">
        <div class="modal-content">
            <h3>Text Expansions</h3>
            <div id="expandersList" style="max-height: 200px; overflow-y: auto;"></div>
            <div class="text-modal-actions">
                <button class="btn" id="addExpanderBtn">Add</button>
                <button class="btn" id="exportExpandersBtn">Export</button>
                <button class="btn" id="importExpandersBtn">Import</button>
            </div>
            <div class="modal-buttons"><button class="btn" id="closeTextModalBtn">Close</button></div>
        </div>
    </div>
    <div id="expanderModal" class="modal">
        <div class="modal-content">
            <h3>Add Text Expansion</h3>
            <div class="input-group"><label for="expanderTrigger">Trigger</label><input type="text" id="expanderTrigger"></div>
            <div class="input-group"><label for="expanderText">Replacement Text</label><textarea id="expanderText"></textarea></div>
            <h4>Dynamic Variables:</h4><code>{date}</code> <code>{time}</code> <code>{datetime}</code> <code>{timestamp}</code>
            <div class="modal-buttons"><button class="btn" id="cancelExpanderBtn">Cancel</button><button class="btn" id="expanderSaveBtn">Add</button></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            class TextEditor {
                constructor() {
                    this.files = new Map();
                    this.fileHandles = new Map();
                    this.activeFileId = null;
                    this.expanders = new Map();
                    this.nextFileId = 1;
                    this.isPreviewActive = false;
                    this.isGridActive = false;

                    this.editorEl = document.getElementById('editor');
                    this.tabsContainerEl = document.getElementById('tabsContainer');
                    this.statusTextEl = document.getElementById('statusText');
                    this.cursorPositionEl = document.getElementById('cursorPosition');
                    this.textModal = document.getElementById('textModal');
                    this.expanderModal = document.getElementById('expanderModal');
                    this.previewPane = document.getElementById('previewPane');
                    this.editorWrapper = document.getElementById('editorWrapper');
                    this.csvGrid = document.getElementById('csvGrid');

                    this.previewBtn = document.getElementById('previewBtn');
                    this.gridModeBtn = document.getElementById('gridModeBtn');
                    this.pdfBtn = document.getElementById('pdfBtn');
                    this.htmlBtn = document.getElementById('htmlBtn');

                    this.init();
                }

                init() {
                    this.setupEventListeners();
                    this.loadExpanders();
                    this.createNewFile();
                }

                setupEventListeners() {
                    // Toolbar buttons
                    document.getElementById('newFileBtn').addEventListener('click', () => this.createNewFile());
                    document.getElementById('openFileBtn').addEventListener('click', () => this.openFile());
                    document.getElementById('saveFileBtn').addEventListener('click', () => this.saveFile());
                    document.getElementById('saveAsFileBtn').addEventListener('click', () => this.saveAsFile());
                    document.getElementById('textBtn').addEventListener('click', () => this.showTextModal());
                    this.previewBtn.addEventListener('click', () => this.togglePreview());
                    this.gridModeBtn.addEventListener('click', () => this.toggleGridMode());
                    this.pdfBtn.addEventListener('click', () => this.exportToPDF());
                    this.htmlBtn.addEventListener('click', () => this.exportToHTML());
                    
                    // Modal buttons
                    document.getElementById('closeTextModalBtn').addEventListener('click', () => this.closeTextModal());
                    document.getElementById('addExpanderBtn').addEventListener('click', () => this.showExpanderModal());
                    document.getElementById('exportExpandersBtn').addEventListener('click', () => this.exportExpanders());
                    document.getElementById('importExpandersBtn').addEventListener('click', () => this.importExpanders());
                    document.getElementById('cancelExpanderBtn').addEventListener('click', () => this.closeExpanderModal());
                    document.getElementById('expanderSaveBtn').addEventListener('click', () => this.addExpander());
                    
                    // Editor and global events
                    this.editorEl.addEventListener('input', () => this.handleEditorInput());
                    this.editorEl.addEventListener('keyup', () => this.updateStatusBar());
                    this.editorEl.addEventListener('click', () => this.updateStatusBar());
                    document.addEventListener('keydown', (e) => this.handleGlobalKeydown(e));
                }
                
                handleGlobalKeydown(e) {
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key.toLowerCase()) {
                            case 'n': e.preventDefault(); this.createNewFile(); break;
                            case 'o': e.preventDefault(); this.openFile(); break;
                            case 's':
                                e.preventDefault();
                                if (e.shiftKey) {
                                    this.saveAsFile();
                                } else {
                                    this.saveFile();
                                }
                                break;
                            case 'p': e.preventDefault(); this.togglePreview(); break;
                            case 'g': e.preventDefault(); this.toggleGridMode(); break;
                            case 'e': e.preventDefault(); this.showTextModal(); break;
                        }
                    }
                }

                togglePreview() {
                    if (!this.files.get(this.activeFileId)?.name.endsWith('.md')) return;
                    this.isPreviewActive = !this.isPreviewActive;
                    this.previewPane.classList.toggle('active', this.isPreviewActive);
                    if (this.isPreviewActive) this.updatePreview();
                }

                updatePreview() {
                    const file = this.files.get(this.activeFileId);
                    if (file && this.isPreviewActive) this.previewPane.innerHTML = marked.parse(file.content);
                }

                toggleGridMode() {
                    if (!this.files.get(this.activeFileId)?.name.endsWith('.csv')) return;
                    this.isGridActive = !this.isGridActive;
                    this.editorWrapper.classList.toggle('grid-mode-active', this.isGridActive);
                    if (this.isGridActive) this.renderCsvGrid();
                }
                
                renderCsvGrid() {
                    const file = this.files.get(this.activeFileId);
                    if (!file) return;

                    const lines = file.content.split('\n');
                    const data = lines.map(line => line.split(','));

                    let tableHTML = '<thead><tr>';
                    (data[0] || []).forEach(header => tableHTML += `<th>${header}</th>`);
                    tableHTML += '</tr></thead><tbody>';

                    data.slice(1).forEach((row, rowIndex) => {
                        tableHTML += '<tr>';
                        row.forEach((cell, colIndex) => {
                            tableHTML += `<td><input type="text" class="csv-grid-input" value="${cell}" data-row="${rowIndex + 1}" data-col="${colIndex}"></td>`;
                        });
                        tableHTML += '</tr>';
                    });
                    this.csvGrid.innerHTML = tableHTML + '</tbody>';

                    this.csvGrid.querySelectorAll('.csv-grid-input').forEach(input => {
                        input.addEventListener('input', () => this.updateCsvFromGrid());
                        input.addEventListener('keydown', (e) => this.handleGridKeydown(e));
                    });
                }

                handleGridKeydown(e) {
                    const { key, target } = e;
                    if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) return;
                    
                    e.preventDefault();
                    
                    let row = parseInt(target.dataset.row, 10);
                    let col = parseInt(target.dataset.col, 10);

                    switch (key) {
                        case 'ArrowUp': row--; break;
                        case 'ArrowDown': row++; break;
                        case 'ArrowLeft': col--; break;
                        case 'ArrowRight': col++; break;
                    }

                    const nextCell = this.csvGrid.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (nextCell) {
                        nextCell.focus();
                        nextCell.select();
                    }
                }

                updateCsvFromGrid() {
                    const headers = Array.from(this.csvGrid.querySelectorAll('th')).map(th => th.textContent);
                    const rows = Array.from(this.csvGrid.querySelectorAll('tbody tr'));
                    let newContent = headers.join(',') + '\n';
                    
                    rows.forEach(row => {
                        const cells = Array.from(row.querySelectorAll('.csv-grid-input')).map(input => input.value);
                        newContent += cells.join(',') + '\n';
                    });

                    const file = this.files.get(this.activeFileId);
                    if (file) {
                        file.content = newContent.trim();
                        file.modified = true;
                        this.editorEl.value = file.content;
                        this.renderTabs();
                    }
                }

                updateToolbarButtons(file) {
                    const isMarkdown = file.name.endsWith('.md');
                    const isCsv = file.name.endsWith('.csv');
                    this.previewBtn.style.display = isMarkdown ? 'inline-block' : 'none';
                    this.pdfBtn.style.display = isMarkdown ? 'inline-block' : 'none';
                    this.htmlBtn.style.display = isMarkdown ? 'inline-block' : 'none';
                    this.gridModeBtn.style.display = isCsv ? 'inline-block' : 'none';
                }

                switchToFile(fileId) {
                    this.activeFileId = fileId;
                    const file = this.files.get(fileId);
                    if (file) {
                        this.editorEl.value = file.content;
                        this.updateToolbarButtons(file);
                        this.isPreviewActive = false;
                        this.isGridActive = false;
                        this.previewPane.classList.remove('active');
                        this.editorWrapper.classList.remove('grid-mode-active');
                    }
                    this.renderTabs();
                    this.updateStatusBar();
                }
                
                createNewFile() {
                    const fileId = `file_${this.nextFileId++}`;
                    const file = { id: fileId, name: `untitled-${this.files.size + 1}.txt`, content: '', modified: false, isLinked: false };
                    this.files.set(fileId, file);
                    this.switchToFile(fileId);
                }

                async openFile() {
                    try {
                        const [handle] = await window.showOpenFilePicker();
                        const fileData = await handle.getFile();
                        const content = await fileData.text();
                        
                        const newFile = { id: `file_${this.nextFileId++}`, name: fileData.name, content: content, modified: false, isLinked: true };
                        this.files.set(newFile.id, newFile);
                        this.fileHandles.set(newFile.id, handle);
                        this.switchToFile(newFile.id);
                    } catch (err) {
                        if (err.name !== 'AbortError') console.error('File open failed.', err);
                    }
                }

                async saveFile() {
                    const file = this.files.get(this.activeFileId);
                    const handle = this.fileHandles.get(this.activeFileId);

                    if (handle) {
                        try {
                            const writable = await handle.createWritable();
                            await writable.write(file.content);
                            await writable.close();
                            file.modified = false;
                            this.renderTabs();
                            this.setStatus(`${file.name} saved.`);
                        } catch (err) {
                            console.error('Error saving file:', err);
                            this.setStatus(`Error saving ${file.name}.`);
                        }
                    } else {
                        this.saveAsFile();
                    }
                }
                
                saveAsFile() {
                    const file = this.files.get(this.activeFileId);
                    if (!file) return;
                    const blob = new Blob([file.content], { type: 'text/plain' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = file.name;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    file.modified = false;
                    this.renderTabs();
                }
                
                handleEditorInput() {
                    const file = this.files.get(this.activeFileId);
                    if (file) {
                        file.content = this.editorEl.value;
                        file.modified = true;
                        this.renderTabs();
                        this.checkTextExpanders(); 
                        if (this.isPreviewActive) this.updatePreview();
                        if (this.isGridActive) this.updateCsvFromGrid();
                    }
                    this.updateStatusBar();
                }

                checkTextExpanders() {
                    const cursorPos = this.editorEl.selectionStart;
                    const textBeforeCursor = this.editorEl.value.substring(0, cursorPos);
                    for (const [trigger, replacement] of this.expanders) {
                        if (trigger && textBeforeCursor.endsWith(trigger)) {
                            const expandedText = this.processExpansion(replacement);
                            this.editorEl.value = this.editorEl.value.substring(0, cursorPos - trigger.length) + expandedText + this.editorEl.value.substring(cursorPos);
                            this.editorEl.setSelectionRange(cursorPos - trigger.length + expandedText.length, cursorPos - trigger.length + expandedText.length);
                            this.handleEditorInput();
                            break;
                        }
                    }
                }

                processExpansion(text) {
                    const now = new Date();
                    return text.replace(/\{date\}/g, now.toLocaleDateString()).replace(/\{time\}/g, now.toLocaleTimeString()).replace(/\{datetime\}/g, now.toLocaleString()).replace(/\{timestamp\}/g, Date.now().toString());
                }
                
                renderTabs() {
                    this.tabsContainerEl.innerHTML = '';
                    this.files.forEach(file => {
                        const modifiedIndicator = file.modified ? '*' : '';
                        const linkedIndicator = file.isLinked ? ' 💾' : '';
                        const tab = document.createElement('div');
                        tab.className = `tab ${file.id === this.activeFileId ? 'active' : ''}`;
                        tab.textContent = file.name + modifiedIndicator + linkedIndicator;
                        tab.title = file.isLinked ? 'Saved directly to your computer' : 'Not saved to a permanent file';
                        tab.addEventListener('click', () => this.switchToFile(file.id));
                        this.tabsContainerEl.appendChild(tab);
                    });
                }

                updateStatusBar() {
                    const file = this.files.get(this.activeFileId);
                    this.statusTextEl.textContent = file ? file.name : 'Ready';
                    const pos = this.editorEl.selectionStart;
                    const text = this.editorEl.value.substring(0, pos);
                    const lines = text.split('\n');
                    this.cursorPositionEl.textContent = `Ln ${lines.length}, Col ${lines[lines.length-1].length + 1}`;
                }

                setStatus(message) {
                    const originalStatus = this.statusTextEl.textContent;
                    this.statusTextEl.textContent = message;
                    setTimeout(() => { this.updateStatusBar(); }, 3000);
                }
                
                exportToPDF() {
                    const file = this.files.get(this.activeFileId);
                    if (!file || !file.name.endsWith('.md')) return;
                    const printWindow = window.open('', '_blank');
                    printWindow.document.write(`
                        <html><head><title>Print</title>
                        <style> @page { size: auto; margin: 20mm; } body { margin: 0; } </style>
                        </head><body>${marked.parse(file.content)}</body></html>
                    `);
                    printWindow.document.close();
                    printWindow.focus();
                    setTimeout(() => { printWindow.print(); printWindow.close(); }, 250);
                }

                exportToHTML() {
                    const file = this.files.get(this.activeFileId);
                    if (!file || !file.name.endsWith('.md')) return;
                    const htmlContent = '<!DOCTYPE html><html><head><title>' + file.name + '</title></head><body>' + marked.parse(file.content) + '</body></html>';
                    const blob = new Blob([htmlContent], { type: 'text/html' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = file.name.replace('.md', '.html');
                    a.click();
                    URL.revokeObjectURL(a.href);
                }

                showTextModal() { this.updateExpandersList(); this.textModal.style.display = 'block'; }
                closeTextModal() { this.textModal.style.display = 'none'; }
                showExpanderModal() { this.expanderModal.style.display = 'block'; }
                closeExpanderModal() { this.expanderModal.style.display = 'none'; }
                
                addExpander() {
                    const trigger = document.getElementById('expanderTrigger').value.trim();
                    const text = document.getElementById('expanderText').value;
                    if (trigger && text) {
                        this.expanders.set(trigger, text);
                        this.saveExpanders();
                        this.closeExpanderModal();
                        this.updateExpandersList();
                    } else {
                        this.setStatus("Trigger and text cannot be empty.");
                    }
                }
                
                updateExpandersList() {
                    const listEl = document.getElementById('expandersList');
                    listEl.innerHTML = '';
                    this.expanders.forEach((text, trigger) => {
                        const item = document.createElement('div');
                        item.className = 'expander-item';
                        const displayText = text.replace(/\n/g, ' ').length > 25 ? text.replace(/\n/g, ' ').substring(0, 25) + '...' : text.replace(/\n/g, ' ');
                        item.innerHTML = `<span><b>${trigger}</b> → ${displayText}</span><span class="delete-expander">Delete</span>`;
                        item.querySelector('.delete-expander').addEventListener('click', () => { this.expanders.delete(trigger); this.saveExpanders(); this.updateExpandersList(); });
                        listEl.appendChild(item);
                    });
                }
                
                exportExpanders() {
                    if (this.expanders.size === 0) {
                        this.setStatus('No expansions to export.');
                        return;
                    }
                    const lines = [];
                    this.expanders.forEach((text, trigger) => {
                        const escapedText = text.replace(/\n/g, '\\n');
                        lines.push(`${trigger}=${escapedText}`);
                    });
                    const data = lines.join('\n');
                    const blob = new Blob([data], { type: 'text/plain' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'editr-expansions.txt';
                    a.click();
                    URL.revokeObjectURL(a.href);
                }

                importExpanders() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.txt';
                    input.onchange = e => {
                        const file = e.target.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = e => {
                            try {
                                const newExpanders = new Map();
                                const lines = e.target.result.split('\n');
                                lines.forEach(line => {
                                    if (line.trim() === '') return;
                                    const separatorIndex = line.indexOf('=');
                                    if (separatorIndex === -1) return;
                                    
                                    const trigger = line.substring(0, separatorIndex);
                                    const escapedText = line.substring(separatorIndex + 1);
                                    const text = escapedText.replace(/\\n/g, '\n');
                                    
                                    if (trigger) {
                                        newExpanders.set(trigger, text);
                                    }
                                });
                                this.expanders = newExpanders;
                                this.saveExpanders();
                                this.updateExpandersList();
                                this.setStatus('Expansions imported successfully.');
                            } catch (err) {
                                this.setStatus('Error: Invalid import file format.');
                                console.error('Import failed:', err);
                            }
                        };
                        reader.readAsText(file);
                    };
                    input.click();
                }

                saveExpanders() { localStorage.setItem('editr_expanders', JSON.stringify(Array.from(this.expanders.entries()))); }
                loadExpanders() {
                    const data = localStorage.getItem('editr_expanders');
                    if (data) {
                        try {
                            this.expanders = new Map(JSON.parse(data));
                        } catch {
                            this.expanders = new Map();
                        }
                    }
                }
            }
            new TextEditor();
        });
    </script>
</body>
</html>